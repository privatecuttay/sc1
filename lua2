local HttpService = game:GetService("HttpService")
local Player = game.Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local hasAccess = false
local inputKey = nil

local discordLink = "https://discord.gg/hnnWQPCHDC"

local masterKey = "Koalahub"

local keyValidTime = 24 * 3600

local function verifyKey(key)
    local response = game:HttpGet("https://solarhub.ngrok.io/verify?key=" .. key)
    local result = HttpService:JSONDecode(response)
    return result.success == true
end

local function loadSavedKey()
    if isfile("Solarhub_key.txt") then
        local data = HttpService:JSONDecode(readfile("Solarhub_key.txt"))
        if data and data.key then
            if data.key == masterKey then
                return data.key, true
            end
            if verifyKey(data.key) then
                return data.key, true
            end
        end
    end
    return nil, false
end

local function saveKey(key)
    local data = { key = key, timestamp = os.time() }
    writefile("Solarhub_key.txt", HttpService:JSONEncode(data))
end

local theme = {
    background = Color3.fromRGB(10, 7, 20),
    foreground = Color3.fromRGB(20, 15, 40),
    accent = Color3.fromRGB(142, 107, 255),
    textPrimary = Color3.fromRGB(255, 255, 255),
    textSecondary = Color3.fromRGB(160, 140, 210),
    success = Color3.fromRGB(67, 181, 129),
    error = Color3.fromRGB(240, 71, 71),
    checkButtonBackground = Color3.fromRGB(60, 40, 110),
    checkButtonHover = Color3.fromRGB(80, 50, 140),
    checkButtonText = Color3.fromRGB(220, 210, 255),
    accentRed = Color3.fromRGB(180, 30, 30),
    cornerRadius = UDim.new(0, 14),
    fontRegular = Enum.Font.GothamMedium,
    fontBold = Enum.Font.GothamBold
}

local function promptForKey()
    local savedKey, valid = loadSavedKey()
    if valid then
        hasAccess = true
        return
    end

    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "SolarHubSystem"
    ScreenGui.Parent = game.CoreGui
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    local MainContainer = Instance.new("Frame")
    MainContainer.Name = "MainContainer"
    MainContainer.Size = UDim2.new(0, 320, 0, 190)
    MainContainer.Position = UDim2.new(0.5, -160, 0.5, -95)
    MainContainer.BackgroundColor3 = theme.background
    MainContainer.BackgroundTransparency = 0
    MainContainer.BorderSizePixel = 0
    MainContainer.Parent = ScreenGui

    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = theme.cornerRadius
    UICorner.Parent = MainContainer

    local Shadow = Instance.new("ImageLabel")
    Shadow.Name = "Shadow"
    Shadow.AnchorPoint = Vector2.new(0.5, 0.5)
    Shadow.BackgroundTransparency = 1
    Shadow.Position = UDim2.new(0.5, 0, 0.5, 0)
    Shadow.Size = UDim2.new(1, 30, 1, 30)
    Shadow.ZIndex = 0
    Shadow.Image = "rbxassetid://5554236805"
    Shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
    Shadow.ImageTransparency = 0.5
    Shadow.ScaleType = Enum.ScaleType.Slice
    Shadow.SliceCenter = Rect.new(23, 23, 277, 277)
    Shadow.Parent = MainContainer

    local TitleContainer = Instance.new("Frame")
    TitleContainer.Name = "TitleBar"
    TitleContainer.Size = UDim2.new(1, 0, 0, 30)
    TitleContainer.BackgroundColor3 = theme.foreground
    TitleContainer.BorderSizePixel = 0
    TitleContainer.Parent = MainContainer

    local TitleUICorner = Instance.new("UICorner")
    TitleUICorner.CornerRadius = theme.cornerRadius
    TitleUICorner.Parent = TitleContainer

    local TitleBottomFrame = Instance.new("Frame")
    TitleBottomFrame.Name = "BottomFix"
    TitleBottomFrame.Size = UDim2.new(1, 0, 0, 10)
    TitleBottomFrame.Position = UDim2.new(0, 0, 1, -10)
    TitleBottomFrame.BackgroundColor3 = theme.foreground
    TitleBottomFrame.BorderSizePixel = 0
    TitleBottomFrame.ZIndex = 0
    TitleBottomFrame.Parent = TitleContainer

    local SolarIcon = Instance.new("ImageLabel")
    SolarIcon.Name = "SolarIcon"
    SolarIcon.Size = UDim2.new(0, 24, 0, 24)
    SolarIcon.Position = UDim2.new(0, 8, 0.5, -12)
    SolarIcon.BackgroundTransparency = 1
    SolarIcon.Image = "rbxassetid://94361536997609"
    SolarIcon.Parent = TitleContainer

    local TitleText = Instance.new("TextLabel")
    TitleText.Name = "Title"
    TitleText.Size = UDim2.new(1, -60, 1, 0)
    TitleText.Position = UDim2.new(0, 36, 0, 0)
    TitleText.BackgroundTransparency = 1
    TitleText.Text = "SOLAR HUB"
    TitleText.Font = theme.fontBold
    TitleText.TextSize = 14
    TitleText.TextColor3 = theme.textPrimary
    TitleText.TextXAlignment = Enum.TextXAlignment.Left
    TitleText.Parent = TitleContainer

    local CloseButton = Instance.new("TextButton")
    CloseButton.Name = "CloseButton"
    CloseButton.Size = UDim2.new(0, 24, 0, 24)
    CloseButton.Position = UDim2.new(1, -28, 0, 3)
    CloseButton.BackgroundColor3 = theme.error
    CloseButton.BorderSizePixel = 0
    CloseButton.Font = theme.fontBold
    CloseButton.Text = "X"
    CloseButton.TextColor3 = theme.textPrimary
    CloseButton.TextSize = 14
    CloseButton.Parent = TitleContainer

    local CloseCorner = Instance.new("UICorner")
    CloseCorner.CornerRadius = UDim.new(0, 6)
    CloseCorner.Parent = CloseButton

    local KeyLabel = Instance.new("TextLabel")
    KeyLabel.Name = "KeyLabel"
    KeyLabel.Size = UDim2.new(1, 0, 0, 20)
    KeyLabel.Position = UDim2.new(0, 0, 0, 35)
    KeyLabel.BackgroundTransparency = 1
    KeyLabel.Font = theme.fontBold
    KeyLabel.Text = "Key Input"
    KeyLabel.TextColor3 = theme.textPrimary
    KeyLabel.TextSize = 14
    KeyLabel.Parent = MainContainer

    local TextBoxContainer = Instance.new("TextBox")
    TextBoxContainer.Name = "KeyInput"
    TextBoxContainer.Size = UDim2.new(1, -20, 0, 30)
    TextBoxContainer.Position = UDim2.new(0, 10, 0, 60)
    TextBoxContainer.BackgroundColor3 = theme.foreground
    TextBoxContainer.BorderSizePixel = 0
    TextBoxContainer.PlaceholderText = "Enter your key here"
    TextBoxContainer.PlaceholderColor3 = Color3.fromRGB(160, 140, 210)
    TextBoxContainer.Text = ""
    TextBoxContainer.TextColor3 = theme.textPrimary
    TextBoxContainer.Font = theme.fontRegular
    TextBoxContainer.TextSize = 12
    TextBoxContainer.Parent = MainContainer

    local TextBoxUICorner = Instance.new("UICorner")
    TextBoxUICorner.CornerRadius = theme.cornerRadius
    TextBoxUICorner.Parent = TextBoxContainer

    local TextBoxGradient = Instance.new("UIGradient")
    TextBoxGradient.Rotation = 90
    TextBoxGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(40, 30, 70)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(30, 22, 55))
    })
    TextBoxGradient.Parent = TextBoxContainer

    local CheckKeyButton = Instance.new("TextButton")
    CheckKeyButton.Name = "CheckKeyButton"
    CheckKeyButton.Size = UDim2.new(1, -20, 0, 30)
    CheckKeyButton.Position = UDim2.new(0, 10, 0, 100)
    CheckKeyButton.BackgroundColor3 = theme.checkButtonBackground
    CheckKeyButton.BorderSizePixel = 0
    CheckKeyButton.Font = theme.fontBold
    CheckKeyButton.Text = "CHECK KEY"
    CheckKeyButton.TextColor3 = theme.checkButtonText
    CheckKeyButton.TextSize = 12
    CheckKeyButton.Parent = MainContainer
    
    local CheckKeyCorner = Instance.new("UICorner")
    CheckKeyCorner.CornerRadius = theme.cornerRadius
    CheckKeyCorner.Parent = CheckKeyButton

    local DiscordButton = Instance.new("TextButton")
    DiscordButton.Name = "DiscordButton"
    DiscordButton.Size = UDim2.new(1, -20, 0, 30)
    DiscordButton.Position = UDim2.new(0, 10, 0, 140)
    DiscordButton.BackgroundColor3 = theme.checkButtonBackground
    DiscordButton.BorderSizePixel = 0
    DiscordButton.Font = theme.fontBold
    DiscordButton.Text = "DISCORD"
    DiscordButton.TextColor3 = theme.checkButtonText
    DiscordButton.TextSize = 12
    DiscordButton.Parent = MainContainer
    
    local DiscordCorner = Instance.new("UICorner")
    DiscordCorner.CornerRadius = theme.cornerRadius
    DiscordCorner.Parent = DiscordButton

    MainContainer.Position = UDim2.new(0.5, -160, 0.6, -95)
    MainContainer.BackgroundTransparency = 1
    Shadow.ImageTransparency = 1

    local entranceTween = TweenService:Create(
        MainContainer,
        TweenInfo.new(0.6, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
        {Position = UDim2.new(0.5, -160, 0.5, -95), BackgroundTransparency = 0}
    )

    local shadowTween = TweenService:Create(
        Shadow,
        TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {ImageTransparency = 0.5}
    )

    entranceTween:Play()
    shadowTween:Play()

    CloseButton.MouseButton1Click:Connect(function()
        ScreenGui:Destroy()
    end)

    TextBoxContainer.Focused:Connect(function()
        local focusTween = TweenService:Create(
            TextBoxContainer,
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {BackgroundColor3 = Color3.fromRGB(40, 30, 70)}
        )
        focusTween:Play()
    end)

    TextBoxContainer.FocusLost:Connect(function()
        local unfocusTween = TweenService:Create(
            TextBoxContainer,
            TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {BackgroundColor3 = theme.foreground}
        )
        unfocusTween:Play()
    end)

    DiscordButton.MouseButton1Click:Connect(function()
        pcall(function()
            setclipboard(discordLink)
            KeyLabel.Text = "Discord link copied to clipboard!"
            KeyLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
            task.wait(2)
            KeyLabel.Text = "Key Input"
            KeyLabel.TextColor3 = theme.textPrimary
        end)
    end)

    local function createButtonEffect(button)
        button.MouseEnter:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = theme.checkButtonHover}):Play()
        end)
        
        button.MouseLeave:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = theme.checkButtonBackground}):Play()
        end)
        
        button.MouseButton1Down:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.1), {Size = button.Size - UDim2.new(0, 2, 0, 2), Position = button.Position + UDim2.new(0, 1, 0, 1)}):Play()
        end)
        
        button.MouseButton1Up:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.1), {Size = button.Size + UDim2.new(0, 2, 0, 2), Position = button.Position - UDim2.new(0, 1, 0, 1)}):Play()
        end)
    end
    
    createButtonEffect(CheckKeyButton)
    createButtonEffect(DiscordButton)

    local function checkKey()
        local key = TextBoxContainer.Text
        
        if key == "" then 
            KeyLabel.Text = "Please enter a key!"
            KeyLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
            
            local originalPos = TextBoxContainer.Position
            local shakeTween1 = TweenService:Create(
                TextBoxContainer,
                TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                {Position = UDim2.new(0, 15, 0, 60)}
            )
            local shakeTween2 = TweenService:Create(
                TextBoxContainer,
                TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                {Position = UDim2.new(0, 5, 0, 60)}
            )
            local shakeTween3 = TweenService:Create(
                TextBoxContainer,
                TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                {Position = originalPos}
            )

            shakeTween1:Play()
            shakeTween1.Completed:Connect(function()
                shakeTween2:Play()
                shakeTween2.Completed:Connect(function()
                    shakeTween3:Play()
                end)
            end)
            
            task.wait(2)
            KeyLabel.Text = "Key Input"
            KeyLabel.TextColor3 = theme.textPrimary
            return 
        end
        
        KeyLabel.Text = "Checking key..."
        KeyLabel.TextColor3 = theme.textPrimary
        CheckKeyButton.Text = "Checking..."
        
        task.spawn(function()
            task.wait(0.5)
            local success = false
            
            if key == masterKey then
                success = true
            else
                pcall(function()
                    success = verifyKey(key)
                end)
            end
            
            if success then
                KeyLabel.Text = "Key verified successfully!"
                KeyLabel.TextColor3 = theme.success
                CheckKeyButton.Text = "Success!"
                CheckKeyButton.BackgroundColor3 = theme.success
                
                saveKey(key)
                
                task.wait(1)
                
                local fadeOutTween = TweenService:Create(
                    MainContainer,
                    TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                    {Position = UDim2.new(0.5, -160, 0.4, -95), BackgroundTransparency = 1}
                )

                local shadowFadeOut = TweenService:Create(
                    Shadow,
                    TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                    {ImageTransparency = 1}
                )

                fadeOutTween:Play()
                shadowFadeOut:Play()

                fadeOutTween.Completed:Connect(function()
                    ScreenGui:Destroy()
                    hasAccess = true
                end)
            else
                KeyLabel.Text = "Invalid key! Please try again."
                KeyLabel.TextColor3 = theme.error
                CheckKeyButton.Text = "Try Again"
                
                local originalPos = TextBoxContainer.Position
                local shakeTween1 = TweenService:Create(
                    TextBoxContainer,
                    TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                    {Position = UDim2.new(0, 15, 0, 60)}
                )
                local shakeTween2 = TweenService:Create(
                    TextBoxContainer,
                    TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                    {Position = UDim2.new(0, 5, 0, 60)}
                )
                local shakeTween3 = TweenService:Create(
                    TextBoxContainer,
                    TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                    {Position = originalPos}
                )

                shakeTween1:Play()
                shakeTween1.Completed:Connect(function()
                    shakeTween2:Play()
                    shakeTween2.Completed:Connect(function()
                        shakeTween3:Play()
                    end)
                end)
                
                task.wait(2)
                KeyLabel.Text = "Key Input"
                KeyLabel.TextColor3 = theme.textPrimary
                CheckKeyButton.Text = "Check Key"
                CheckKeyButton.BackgroundColor3 = theme.checkButtonBackground
            end
        end)
    end
    
    CheckKeyButton.MouseButton1Click:Connect(checkKey)
    
    TextBoxContainer.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            checkKey()
        end
    end)

    repeat task.wait() until hasAccess
end

promptForKey()

local Solar = loadstring(Game:HttpGet("https://raw.githubusercontent.com/HuynkKhoa1/SolarhubUI001/refs/heads/main/Custom_Solar.lua", true))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Th4nh1204/SaveManager.lua/refs/heads/main/Solar"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/Th4nh1204/InterfaceManager.lua/refs/heads/main/Solar"))()

local Window = Solar:CreateWindow({
    Title = "Arise Crossover ",
    SubTitle = "by SolarHub",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "Solar",
    MinimizeKey = Enum.KeyCode.LeftControl
})

local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "carrot" }),
    Auto = Window:AddTab({ Title = "Farm", Icon = "repeat" }),
    Dungeon = Window:AddTab({ Title = "Dungeon", Icon = "gamepad" }),
    Shop = Window:AddTab({ Title = "Shop", Icon = "shopping-cart" }),
    Webhook = Window:AddTab({ Title = "Webhook", Icon = "webhook" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local player = game.Players.LocalPlayer
local replicatedStorage = game:GetService("ReplicatedStorage")
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local defeatedEnemies = {}

local autoPetThread = nil
local isAutoPetActive = false

local autoRejoinEnabled = false
local autoRejoinConnection = nil
local autoRejoinDungeonEnabled = false
local autoRejoinDungeonThread = nil
local dungeonRejoinFloor = 30

local useCheckpointCastle = false

local autoAriseThread = nil
local autoDestroyThread = nil

local autoPunchThread = nil
local autoPunchEnabled = false

local tpToCFrameThread = nil

local startTime = os.time()

local Options = {
    FastAttackToggle = false,
    TeleportActive = false,
    AriseActive = false,
    DestroyActive = false,
    Distance = 5,
    TweenSpeed = 50,
    FirePortalMaxDistance = 500,
    BossFarmActive = false,
    MovementMethod = "TP",
    HybridThreshold = 100,
    SelectedIsland = "All Islands",
    SelectedEnemyTypes = {},
    FarmAllEnemies = true
}

local eventHashes = {
    ["Attack"] = {"\6", "\5"},
    ["PunchAttack"] = {"\5", "\4"},
    ["EnemyCapture"] = {"\5", "\4"},
    ["EnemyDestroy"] = {"\5", "\4"},
    ["DungeonAction"] = {"\11", "\10"},
    ["CastleAction"] = {"\11", "\10"},
    ["ItemShopAction"] = {"\11", "\10"},
    ["UpgradeWeapon"] = {"\11", "\10"}
}

local currentHashIndex = {
    ["Attack"] = 1,
    ["PunchAttack"] = 1, 
    ["EnemyCapture"] = 1,
    ["EnemyDestroy"] = 1,
    ["DungeonAction"] = 1,
    ["CastleAction"] = 1,
    ["ItemShopAction"] = 1,
    ["UpgradeWeapon"] = 1
}

local function executeRemoteWithHashRotation(eventName, args)
    local hash = eventHashes[eventName][currentHashIndex[eventName]]
    
    local fullArgs = {
        {
            args,
            hash
        }
    }
    
    local success = pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("BridgeNet2"):WaitForChild("dataRemoteEvent"):FireServer(unpack(fullArgs))
    end)
    
    currentHashIndex[eventName] = (currentHashIndex[eventName] % #eventHashes[eventName]) + 1
    
    return success
end

local islandEnemies = {
    ["SoloLeveling Island"] = {
        {id = "SL1", name = "Soondoo"},
        {id = "SL2", name = "Gonshee"},
        {id = "SL3", name = "Daek"},
        {id = "SL4", name = "Longin"},
        {id = "SL5", name = "Anders"},
        {id = "SL6", name = "Largalgan"}
    },
    ["Naruto Island"] = {
        {id = "NR1", name = "Snake Man"},
        {id = "NR2", name = "Blossom"},
        {id = "NR3", name = "Black Crow"}
    },
    ["OnePiece Island"] = {
        {id = "OP1", name = "Shark Man"},
        {id = "OP2", name = "Eminel"},
        {id = "OP3", name = "Light Admiral"}
    },
    ["BlackClover Island"] = {
        {id = "BC1", name = "Sortudo"},
        {id = "BC2", name = "Michille"},
        {id = "BC3", name = "Wind"}
    },
    ["Bleach Island"] = {
        {id = "BL1", name = "Luryu"},
        {id = "BL2", name = "Fyakuya"},
        {id = "BL3", name = "Genji"}
    },
    ["ChainsawMan Island"] = {
        {id = "CH1", name = "Heaven"},
        {id = "CH2", name = "Zere"},
        {id = "CH3", name = "Ika"}
    },
    ["Jojo Island"] = {
        {id = "JB1", name = "Diablo"},
        {id = "JB2", name = "Gosuke"},
        {id = "JB3", name = "Golyne"}
    },
    ["DragonBall Island"] = {
        {id = "DB1", name = "Turle"},
        {id = "DB2", name = "Green"},
        {id = "DB3", name = "Sky"}
    },
    ["OPM Island"] = {
        {id = "OPM1", name = "Rider"},
        {id = "OPM2", name = "Cyborg"},
        {id = "OPM3", name = "Hurricane"}
    },
    ["Kindama Island"] = {
        {id = "DAM1", name = "Shrimp"},
        {id = "DAM2", name = "Baira"},
        {id = "DAM3", name = "Lomo"}
    },
    ["Winter Island"] = {
        {id = "WElf1", name = "Elf Soldier"},
        {id = "WElf2", name = "High Frost"},
        {id = "WBoss", name = "Ladura"},
        {id = "WBoss2", name = "Snow Mornach"},
        {id = "WIron", name = "Metal"},
        {id = "WBear", name = "Winter Bear"}
    }
}
local islandBosses = {
    ["SoloLeveling Island"] = {
        {id = "SLB1", name = "Soondoo"},
        {id = "SLB2", name = "Gonshee"},
        {id = "SLB3", name = "Daek"},
        {id = "SLB4", name = "Longin"},
        {id = "SLB5", name = "Anders"},
        {id = "SLB6", name = "Largalgan"}
    },
    ["Naruto Island"] = {
        {id = "NRB1", name = "Snake Man"},
        {id = "NRB2", name = "Blossom"},
        {id = "NRB3", name = "Black Crow"}
    },
    ["OnePiece Island"] = {
        {id = "OPB1", name = "Shark Man"},
        {id = "OPB2", name = "Eminel"},
        {id = "OPB3", name = "Light Admiral"}
    },
    ["BlackClover Island"] = {
        {id = "BCB1", name = "Sortudo"},
        {id = "BCB2", name = "Michille"},
        {id = "BCB3", name = "Wind"}
    },
    ["Bleach Island"] = {
        {id = "BLB1", name = "Luryu"},
        {id = "BLB2", name = "Fyakuya"},
        {id = "BLB3", name = "Genji"}
    },
    ["ChainsawMan Island"] = {
        {id = "CHB1", name = "Heaven"},
        {id = "CHB2", name = "Zere"},
        {id = "CHB3", name = "Ika"}
    },
    ["Jojo Island"] = {
        {id = "JBB1", name = "Diablo"},
        {id = "JBB2", name = "Gosuke"},
        {id = "JBB3", name = "Golyne"}
    },
    ["DragonBall Island"] = {
        {id = "DBB1", name = "Turle"},
        {id = "DBB2", name = "Green"},
        {id = "DBB3", name = "Sky"}
    },
    ["OPM Island"] = {
        {id = "OPMB1", name = "Rider"},
        {id = "OPMB2", name = "Cyborg"},
        {id = "OPMB3", name = "Hurricane"}
    },
    ["Kindama Island"] = {
        {id = "DAMB1", name = "Shrimp"},
        {id = "DAMB2", name = "Baira"},
        {id = "DAMB3", name = "Lomo"}
    },
}

local islandsCFrames = {
    ["Winter Island"] = CFrame.new(4623.21923828125, 27.50836944580078, -1932.6669921875),
    ["SoloLeveling Island"] = CFrame.new(577.96826171875, 25.934627532958984, 261.4522705078125),
    ["Naruto Island"] = CFrame.new(-3380.2373046875, 27.760528564453125, 2257.261962890625),
    ["OnePiece Island"] = CFrame.new(-2851.106201171875, 46.89878845214844, -2011.395263671875),
    ["BlackClover Island"] = CFrame.new(198.33868408203125, 36.207679748535156, 4296.109375),
    ["Bleach Island"] = CFrame.new(2641.795166015625, 42.92652893066406, -2645.07568359375),
    ["ChainsawMan Island"] = CFrame.new(198.6918182373047, 34.89562225341797, -4455.44677734375),
    ["Jojo Island"] = CFrame.new(4816.31640625, 27.442340850830078, -120.22998046875),
    ["DragonBall Island"] = CFrame.new(-6295.89208984375, 24.698104858398438, -73.71493530273438),
    ["OPM Island"] = CFrame.new(5633.904296875, 22.894081115722656, 4555.0498046875),
    ["Kindama Island"] = CFrame.new(-4374.353515625, 19.462051391601562, 5588.177734375)
}
local islands = {
    "Winter Island",
    "SoloLeveling Island", 
    "Naruto Island", 
    "OnePiece Island", 
    "BlackClover Island", 
    "Bleach Island", 
    "ChainsawMan Island", 
    "Jojo Island", 
    "DragonBall Island",
    "OPM Island",
    "Kindama Island"
}
local shopItems = {
    ["WeaponShop1"] = {
        {internalName = "SpikeMace", displayName = "[1] Spiked Maul"},
        {internalName = "GemStaff", displayName = "[2] Jeweled Rod"},
        {internalName = "DualKando", displayName = "[3] Twin Kando Blades"},
        {internalName = "CrystalScepter", displayName = "[4] Prism Scepter"},
        {internalName = "DualBoneMace", displayName = "[5] Twin Bone Crushers"},
        {internalName = "DualSteelNaginata", displayName = "[6] Twin Iron Naginatas"}
    },
    ["WeaponShop2"] = {
        {internalName = "MonsterSlayer", displayName = "[1]  Beast Bane"},
        {internalName = "DualBasicStaffs", displayName = "[2] Twin Simple Wands"},
        {internalName = "PirateSaber", displayName = "[3] Corsair Blade"},
        {internalName = "MixedBattleAxe", displayName = "[4] Hybird War Axe"},
        {internalName = "BronzeGreatAxe", displayName = "[5] Bronze War Axe"},
        {internalName = "DualAncientMace", displayName = "[6] Twin Relic Maces"}
    },
    ["WeaponShop3"] = {
        {internalName = "DualPirateSaber", displayName = "[1] Twin Corsair Blades"},
        {internalName = "DualSteelSabers", displayName = "[2] Twin Iron Sabers"},
        {internalName = "SteelSabers", displayName = "[3] Iron Saber"},
        {internalName = "SteelButterfly", displayName = "[4] Iron Wingblade"},
        {internalName = "DualSteelButterfly", displayName = "[5] Twin Iron Wingblades"},
        {internalName = "SteelKando", displayName = "[6] Iron Kando Blades"}
    },
    ["WeaponShop4"] = {
        {internalName = "DualGreatSaber", displayName = "[1] Twin Colossal Sabers"},
        {internalName = "BasicStaff", displayName = "[2] Simple Staff"},
        {internalName = "StellKopesh", displayName = "[3] Steel Khopesh"},
        {internalName = "GreatTrident", displayName = "[4] Titan Trident"},
        {internalName = "DualCrystalScepter", displayName = "[5] Twin Prism Scepters"},
        {internalName = "DualTrident", displayName = "[6] Twin Tridents"}
    },
    ["WeaponShop5"] = {
        {internalName = "SteelNaginata", displayName = "[1] Iron Naginate"},
        {internalName = "GreatKopesh", displayName = "[2] Titan Khopesh"},
        {internalName = "BoneMace", displayName = "[3] Bone Crusher"},
        {internalName = "AncientMace", displayName = "[4] Relic Mace"},
        {internalName = "CrimsonStaff", displayName = "[5] Scarlet Staff"},
        {internalName = "GreatSaber", displayName = "[6] Colossal Saber"}
    },
    ["WeaponShop6"] = {
        {internalName = "OzSword2", displayName = "[1] Emerald Blade"},
        {internalName = "CrystalSword2", displayName = "[2] Prism Blade"},
        {internalName = "ObsidianDualAxe2", displayName = "[3] Obsidian Axe"},
        {internalName = "SilverSpear2", displayName = "[4] Argent Spear"},
        {internalName = "DragonAxe2", displayName = "[5] Draconic Axe"},
        {internalName = "DualDivineAxe2", displayName = "[6] Twin Sacred Axes"}
    },
    ["WeaponShop7"] = {
        {internalName = "BloodStaff2", displayName = "[1] Crimson Rod"},
        {internalName = "DualCrimsonStaff2", displayName = "[2] Twin Crimson Rods"},
        {internalName = "DualGemStaffs2", displayName = "[3] Twin Jeweled Rods"},
        {internalName = "GreatScythe2", displayName = "[4] Colossal Scythe"},
        {internalName = "TwinObsidianDualStaff2", displayName = "[5] Dual Obsidian Axes"},
        {internalName = "SlayerScythe2", displayName = "[6] Reaper's Scythe"}
    },
    ["WeaponShop8"] = {
        {internalName = "BeholderStaff2", displayName = "[1] Eye Rod"},
        {internalName = "TwinMixedAxe2", displayName = "[2] Dual Hybird Axes"},
        {internalName = "TwinTrollSlayer2", displayName = "[3] Double Troll Bane"},
        {internalName = "RuneAxe2", displayName = "[4] Runic Axe"},
        {internalName = "DualSliverSpear2", displayName = "[5] Twin Argent Spears"},
        {internalName = "DualDragonAxe2", displayName = "[6] Twin Draconic Axes"}
    },
    ["WeaponShop9"] = {
        {internalName = "SteelSword2", displayName = "[1] Steel Sword"},
        {internalName = "SteelSpear2", displayName = "[2] Steel Spear"},
        {internalName = "StarSpear2", displayName = "[3] Stellar Lance"},
        {internalName = "BoneStaff2", displayName = "[4] Bone Staff"},
        {internalName = "SunGreatAxe2", displayName = "[5] Solar War Axe"},
        {internalName = "EnergyGreatSword2", displayName = "[6] Charged Blade"}
    },
    ["WeaponShop10"] = {
        {internalName = "StealAxe2", displayName = "[1] Steal Axe"},
        {internalName = "SteelGreateAxe2", displayName = "[2] Steel Greate Axe"},
        {internalName = "TwinBeholderStaffs2", displayName = "[3] Dual Beholder Rods"},
        {internalName = "ObsidianGlaive2", displayName = "[4] Obsidian Glaive"},
        {internalName = "DualSunGreatAxe2", displayName = "[5] Twin Solar Axes"},
        {internalName = "DivineHammer2", displayName = "[6] Sacred Maul"}
    }
}

local selectMobFarmOptions = {
    selectedIsland = "SoloLeveling Island",
    selectedMobId = nil,
    isAutoFarmEnabled = false
}

local selectBossFarmOptions = {
    selectedIsland = "SoloLeveling Island",
    selectedBossId = nil,
    isAutoBossFarmEnabled = false
}

local winterMobFarmOptions = {
    selectedIsland = "Winter Island",
    selectedMobId = nil,
    isAutoFarmEnabled = false
}

local levelMap = {
    ["E"] = 1,
    ["D"] = 2,
    ["C"] = 3,
    ["B"] = 4,
    ["A"] = 5,
    ["S"] = 6,
    ["SS"] = 7
}

local weaponUpgradeInfo = {
    weaponName = "",
    targetLevel = 2,
    autoUpgradeEnabled = false
}
local autoFarmStates = {
    autoPunch = false,
    autoArise = false,
    autoDestroy = false,
    autoBoss = false,
    autoFarm = false,
    autoSelectMob = false
}
local targetSystem = {
    current = nil,
    previous = nil,
    changeTime = 0,
    isChanging = false,
    type = "none",
    lastTargetChangeTime = 0
}

local function getItemDisplayNames(shopKey)
    if not shopItems or not shopItems[shopKey] then return {} end
    
    local displayNames = {}
    for _, item in ipairs(shopItems[shopKey]) do
        if item and item.displayName then
            table.insert(displayNames, item.displayName)
        end
    end
    return displayNames
end

local function findInternalItemName(shopKey, displayName)
    if not shopItems or not shopItems[shopKey] or not displayName then return nil end
    
    for _, item in ipairs(shopItems[shopKey]) do
        if item and item.displayName == displayName then
            return item.internalName
        end
    end
    return nil
end

local shopDisplayOrder = {
    {internal = "WeaponShop1", display = "SoloLeveling Shop"},
    {internal = "WeaponShop2", display = "Naruto Shop"},
    {internal = "WeaponShop3", display = "OnePiece Shop"},
    {internal = "WeaponShop4", display = "BlackClover Shop"},
    {internal = "WeaponShop5", display = "Bleach Shop"},
    {internal = "WeaponShop6", display = "ChainsawMan Shop"},
    {internal = "WeaponShop7", display = "Jojo Shop"},
    {internal = "WeaponShop8", display = "DragonBall Shop"},
    {internal = "WeaponShop9", display = "OPM Shop"},
    {internal = "WeaponShop9", display = "Kindama Shop"}
}

-- Create lookup tables
local selectedIsland = "SoloLeveling Island"
local specificCFrame = islandsCFrames[selectedIsland]
local shopDisplayNames = {}
local shopInternalNames = {}
local shopDisplayValues = {}

for _, item in ipairs(shopDisplayOrder) do
    shopDisplayNames[item.internal] = item.display
    shopInternalNames[item.display] = item.internal
    table.insert(shopDisplayValues, item.display)
end

local selectedShop = "WeaponShop1"
local selectedItemDisplay = shopItems[selectedShop][1].displayName
local selectedItemInternal = shopItems[selectedShop][1].internalName

--====== UTILITY FUNCTIONS ======

local function findFirePortalInRange()
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    local worldContainer = workspace.__Main.__World
    if not worldContainer then
        return nil, nil
    end
    
    for _, room in pairs(worldContainer:GetChildren()) do
        if string.match(room.Name, "^Room_%d+$") then
            local firePortal = room:FindFirstChild("FirePortal")
            if firePortal then
                local distance = (firePortal.Position - humanoidRootPart.Position).Magnitude
                if distance <= Options.FirePortalMaxDistance then
                    return firePortal, distance
                else
                end
            end
        end
    end
    
    local firePortal = worldContainer:FindFirstChild("FirePortal")
    if firePortal then
        local distance = (firePortal.Position - humanoidRootPart.Position).Magnitude
        if distance <= Options.FirePortalMaxDistance then
            return firePortal, distance
        else
        end
    end
    
    return nil, nil
end

local function teleportToFirePortalAndInteract()
    local firePortal, distance = findFirePortalInRange()
    
    if not firePortal then
        return false
    end
    
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    local targetCFrame = firePortal.CFrame * CFrame.new(0, 0, -4)
    
    local tweenService = game:GetService("TweenService")
    local tweenTime = distance / 250
    tweenTime = math.min(tweenTime, 10)
    
    local tweenInfo = TweenInfo.new(
        tweenTime,
        Enum.EasingStyle.Linear,
        Enum.EasingDirection.Out,
        0,
        false,
        0
    )
    
    local tween = tweenService:Create(
        humanoidRootPart,
        tweenInfo,
        {CFrame = targetCFrame}
    )
    
    tween:Play()
    tween.Completed:Wait()
    
    task.wait(0.5)
    
    local lookAtPortal = CFrame.lookAt(humanoidRootPart.Position, firePortal.Position)
    humanoidRootPart.CFrame = lookAtPortal
    
    local proximityPrompt = firePortal:FindFirstChild("ProximityPrompt")
    if proximityPrompt then
        fireproximityprompt(proximityPrompt)
    end
    
    task.wait(0.5)
    
    return true
end

local function punchAttack(enemyId)
    if not enemyId or type(enemyId) ~= "string" then
        return
    end
    
    local args = {
        ["Event"] = "PunchAttack",
        ["Enemy"] = enemyId
    }
    
    executeRemoteWithHashRotation("PunchAttack", args)
end

local function teleportToIsland(cframe)
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    for i = 1, 4 do
        pcall(function()
            humanoidRootPart.CFrame = cframe
        end)
        task.wait(0.1)
    end
    task.wait(0.5)
end

local function moveToCurrentTarget()
    if targetSystem.isChanging then
        return true
    end
    if not targetSystem.current or not targetSystem.current.Parent then
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:WaitForChild("Humanoid")
        return false
    end
    local isDead = targetSystem.current:GetAttribute("Dead")
    if isDead == true then
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:WaitForChild("Humanoid")
        targetSystem.current = nil
        return false
    end
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid") 
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    local direction = (targetSystem.current.Position - humanoidRootPart.Position).Unit
    local targetPosition = targetSystem.current.Position - direction * Options.Distance
    local targetCFrame = CFrame.lookAt(targetPosition, targetSystem.current.Position)
    local distanceToTarget = (targetPosition - humanoidRootPart.Position).Magnitude
    local teleportThreshold = 3
    if Options.MovementMethod == "TP" then
        if distanceToTarget > teleportThreshold then
            humanoidRootPart.CFrame = targetCFrame
            task.wait(0.05)
        end
    elseif Options.MovementMethod == "Tween" then
        local tweenService = game:GetService("TweenService")
        local tweenTime = distanceToTarget / Options.TweenSpeed
        tweenTime = math.min(tweenTime, 10)
        local tweenInfo = TweenInfo.new(
            tweenTime,
            Enum.EasingStyle.Linear,
            Enum.EasingDirection.Out,
            0,
            false,
            0
        )
        local tween = tweenService:Create(
            humanoidRootPart,
            tweenInfo,
            {CFrame = targetCFrame}
        )
        tween:Play()
        tween.Completed:Wait()
    elseif Options.MovementMethod == "Hybrid" then
        if distanceToTarget <= Options.HybridThreshold then
            if distanceToTarget > teleportThreshold then
                humanoidRootPart.CFrame = targetCFrame
                task.wait(0.05)
            end
        else
            local tweenService = game:GetService("TweenService")
            local tweenTime = distanceToTarget / Options.TweenSpeed
            tweenTime = math.min(tweenTime, 10)
            
            local tweenInfo = TweenInfo.new(
                tweenTime,
                Enum.EasingStyle.Linear,
                Enum.EasingDirection.Out,
                0,
                false,
                0
            )
            local tween = tweenService:Create(
                humanoidRootPart,
                tweenInfo,
                {CFrame = targetCFrame}
            )
            local connection
            connection = game:GetService("RunService").Heartbeat:Connect(function()
                local currentDistance = (targetSystem.current.Position - humanoidRootPart.Position).Magnitude
                local currentDirection = (targetSystem.current.Position - humanoidRootPart.Position).Unit
                local currentTargetPosition = targetSystem.current.Position - currentDirection * Options.Distance
                if currentDistance <= Options.HybridThreshold + Options.Distance then
                    tween:Cancel()
                    connection:Disconnect()
                    local finalTargetCFrame = CFrame.lookAt(currentTargetPosition, targetSystem.current.Position)
                    humanoidRootPart.CFrame = finalTargetCFrame
                end
            end)
            tween:Play()
            tween.Completed:Wait()
            if connection then
                connection:Disconnect()
            end
        end
    end
    local attackCooldown = 0.1
    if not targetSystem.lastAttackTime or (tick() - targetSystem.lastAttackTime) >= attackCooldown then
        punchAttack(targetSystem.current.Name)
        targetSystem.lastAttackTime = tick()
    end
    task.spawn(function()
        task.wait(1.0)
    end)
    return true
end

local lastTargetChangeTime = 0
local targetChangeCooldown = 0.5
local function setNewTarget(target, targetType)
    if not target then return false end
    
    local currentTime = tick()
    
    local currentTargetValid = targetSystem.current and 
                              targetSystem.current.Parent and 
                              targetSystem.current:GetAttribute("Dead") ~= true
    
    if (not currentTargetValid or (currentTime - lastTargetChangeTime >= targetChangeCooldown)) and target ~= targetSystem.current then
        targetSystem.previous = targetSystem.current
        targetSystem.changeTime = currentTime
        targetSystem.isChanging = true
        targetSystem.type = targetType or "normal"
        lastTargetChangeTime = currentTime
        
        task.delay(targetChangeCooldown, function()
            if targetSystem.isChanging then
                targetSystem.current = target
                targetSystem.isChanging = false
            end
        end)
        
        return true
    end
    
    return false
end

local globalFarmThread = nil
local farmPriority = {
    winter = true,
    specificMob = false,
    boss = false,
    normal = false,
    dungeon = false,
    castle = false
}

local function findNormalEnemyTarget()
    local serverContainer = workspace.__Main.__Enemies.Server
    if not serverContainer then 
        return false 
    end
    
    local nearestEnemy = nil
    local shortestDistance = math.huge
    
    for _, folder in pairs(serverContainer:GetChildren()) do
        for _, part in pairs(folder:GetChildren()) do
            if part:IsA("BasePart") then
                local scale = part:GetAttribute("Scale") or 0
                local isDead = part:GetAttribute("Dead")
                
                if scale == 1 and isDead ~= true then
                    local distance = (part.Position - humanoidRootPart.Position).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        nearestEnemy = part
                    end
                end
            end
        end
    end
    
    for _, part in pairs(serverContainer:GetChildren()) do
        if part:IsA("BasePart") then
            local scale = part:GetAttribute("Scale") or 0
            local isDead = part:GetAttribute("Dead")
            
            if scale == 1 and isDead ~= true then
                local distance = (part.Position - humanoidRootPart.Position).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestEnemy = part
                end
            end
        end
    end
    
    if nearestEnemy then
        setNewTarget(nearestEnemy, "normal")
        return true
    end
    
    return false
end

local function findDungeonTarget()
    local serverContainer = workspace.__Main.__Enemies.Server
    if not serverContainer then 
        return false 
    end
    
    local nearestEnemy = nil
    local shortestDistance = math.huge
    
    for _, part in pairs(serverContainer:GetChildren()) do
        if part:IsA("BasePart") then
            local isDead = part:GetAttribute("Dead")
            local enemyType = part:GetAttribute("Type")
            
            if isDead ~= true and enemyType == "Dungeon" then
                local distance = (part.Position - humanoidRootPart.Position).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestEnemy = part
                end
            end
        end
    end
    
    for _, folder in pairs(serverContainer:GetChildren()) do
        if typeof(folder) == "Instance" and folder:IsA("Folder") then
            for _, part in pairs(folder:GetChildren()) do
                if part:IsA("BasePart") then
                    local isDead = part:GetAttribute("Dead")
                    local enemyType = part:GetAttribute("Type")
                    
                    if isDead ~= true and enemyType == "Dungeon" then
                        local distance = (part.Position - humanoidRootPart.Position).Magnitude
                        if distance < shortestDistance then
                            shortestDistance = distance
                            nearestEnemy = part
                        end
                    end
                end
            end
        end
    end
    
    if nearestEnemy then
        setNewTarget(nearestEnemy, "dungeon")
        return true
    end
    
    return false
end

local function findCastleEnemyTarget()
    local serverContainer = workspace.__Main.__Enemies.Server
    if not serverContainer then 
        return false 
    end
    
    local nearestEnemy = nil
    local shortestDistance = math.huge
    
    for _, part in pairs(serverContainer:GetChildren()) do
        if part:IsA("BasePart") then
            local isDead = part:GetAttribute("Dead")
            local enemyType = part:GetAttribute("Type")
            
            if isDead ~= true and enemyType == "Castle" then
                local distance = (part.Position - humanoidRootPart.Position).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestEnemy = part
                end
            end
        end
    end
    
    for _, folder in pairs(serverContainer:GetChildren()) do
        if typeof(folder) == "Instance" and folder:IsA("Folder") then
            for _, part in pairs(folder:GetChildren()) do
                if part:IsA("BasePart") then
                    local isDead = part:GetAttribute("Dead")
                    local enemyType = part:GetAttribute("Type")
                    
                    if isDead ~= true and enemyType == "Castle" then
                        local distance = (part.Position - humanoidRootPart.Position).Magnitude
                        if distance < shortestDistance then
                            shortestDistance = distance
                            nearestEnemy = part
                        end
                    end
                end
            end
        end
    end
    
    if nearestEnemy then
        setNewTarget(nearestEnemy, "castle")
        return true
    end
    
    return false
end

local function findSpecificMobTarget()
    if not selectMobFarmOptions.selectedMobId then 
        return false 
    end
    
    local serverContainer = workspace.__Main.__Enemies.Server
    if not serverContainer then 
        return false 
    end
    
    local nearestEnemy = nil
    local shortestDistance = math.huge
    
    for _, folder in pairs(serverContainer:GetChildren()) do
        for _, part in pairs(folder:GetChildren()) do
            if part:IsA("BasePart") then
                local enemyId = part:GetAttribute("Id")
                local scale = part:GetAttribute("Scale") or 0
                local isDead = part:GetAttribute("Dead")
                
                if enemyId == selectMobFarmOptions.selectedMobId and scale == 1 and isDead ~= true then
                    local distance = (part.Position - humanoidRootPart.Position).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        nearestEnemy = part
                    end
                end
            end
        end
    end
    
    for _, part in pairs(serverContainer:GetChildren()) do
        if part:IsA("BasePart") then
            local enemyId = part:GetAttribute("Id")
            local scale = part:GetAttribute("Scale") or 0
            local isDead = part:GetAttribute("Dead")
            
            if enemyId == selectMobFarmOptions.selectedMobId and scale == 1 and isDead ~= true then
                local distance = (part.Position - humanoidRootPart.Position).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestEnemy = part
                end
            end
        end
    end
    
    if nearestEnemy then
        setNewTarget(nearestEnemy, "specific")
        return true
    end
    
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    local targetIsland = selectMobFarmOptions.selectedIsland
    local targetCFrame = islandsCFrames[targetIsland]
    
    local distanceToIsland = (humanoidRootPart.Position - targetCFrame.Position).Magnitude
    
    if distanceToIsland > 2500 then
        teleportToIsland(targetCFrame)
        task.wait(1)
        return false
    end
    
    return false
end

local function findSpecificBossTarget()
    if not selectBossFarmOptions.selectedBossId or 
       type(selectBossFarmOptions.selectedBossId) ~= "table" or 
       #selectBossFarmOptions.selectedBossId == 0 then 
        return false 
    end
    
    local serverContainer = workspace.__Main.__Enemies.Server
    if not serverContainer then 
        return false 
    end
    
    local nearestEnemy = nil
    local shortestDistance = math.huge
    
    for i = 1, #selectBossFarmOptions.selectedBossId do
        local bossId = selectBossFarmOptions.selectedBossId[i]
        
        for _, folder in pairs(serverContainer:GetChildren()) do
            for _, part in pairs(folder:GetChildren()) do
                if part:IsA("BasePart") then
                    local enemyId = part:GetAttribute("Id")
                    local scale = part:GetAttribute("Scale") or 0
                    local isDead = part:GetAttribute("Dead")
                    
                    if enemyId == bossId and scale == 2 and isDead ~= true then
                        local distance = (part.Position - humanoidRootPart.Position).Magnitude
                        if distance < shortestDistance then
                            shortestDistance = distance
                            nearestEnemy = part
                        end
                    end
                end
            end
        end
    end
    
    if nearestEnemy then
        setNewTarget(nearestEnemy, "specific_boss")
        return true
    end
    
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    local targetIsland = selectBossFarmOptions.selectedIsland
    local targetCFrame = islandsCFrames[targetIsland]
    
    local distanceToIsland = (humanoidRootPart.Position - targetCFrame.Position).Magnitude
    
    if distanceToIsland > 2500 then
        teleportToIsland(targetCFrame)
        task.wait(1)
        return false
    end
    
    return false
end

local function findSpecificWinterMobTarget()
    if not winterMobFarmOptions.selectedMobIds or #winterMobFarmOptions.selectedMobIds == 0 then 
        return false 
    end
    
    local serverContainer = workspace.__Main.__Enemies.Server
    if not serverContainer then 
        return false 
    end
    
    local nearestEnemy = nil
    local shortestDistance = math.huge
    
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    local function isIdSelected(enemyId)
        for _, selectedId in ipairs(winterMobFarmOptions.selectedMobIds) do
            if enemyId == selectedId then
                return true
            end
        end
        return false
    end
    
    for _, part in pairs(serverContainer:GetChildren()) do
        if part:IsA("BasePart") then
            local enemyId = part:GetAttribute("Id")
            local scale = part:GetAttribute("Scale") or 0
            local isDead = part:GetAttribute("Dead")
            
            if isIdSelected(enemyId) and scale >= 1 and isDead ~= true then
                local distance = (part.Position - humanoidRootPart.Position).Magnitude
                
                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestEnemy = part
                end
            end
        end
    end
    
    for _, folder in pairs(serverContainer:GetChildren()) do
        if typeof(folder) == "Instance" and folder:IsA("Folder") then
            for _, part in pairs(folder:GetChildren()) do
                if part:IsA("BasePart") then
                    local enemyId = part:GetAttribute("Id")
                    local scale = part:GetAttribute("Scale") or 0
                    local isDead = part:GetAttribute("Dead")
                    
                    if isIdSelected(enemyId) and scale >= 1 and isDead ~= true then
                        local distance = (part.Position - humanoidRootPart.Position).Magnitude
                        
                        if distance < shortestDistance then
                            shortestDistance = distance
                            nearestEnemy = part
                        end
                    end
                end
            end
        end
    end
    
    if nearestEnemy then
        setNewTarget(nearestEnemy, "specific_winter")
        return true
    end
    
    local targetIsland = "Winter Island"
    local targetCFrame = islandsCFrames[targetIsland]
    
    local distanceToIsland = (humanoidRootPart.Position - targetCFrame.Position).Magnitude
    
    if distanceToIsland > 2500 then
        teleportToIsland(targetCFrame)
        task.wait(1)
        return false
    end
    
    return false
end

local function findPriorityTarget()
    if winterMobFarmOptions.isAutoFarmEnabled and farmPriority.winter then
        local foundWinterTarget = findSpecificWinterMobTarget()
        if foundWinterTarget then
            return true
        end
    end
    
    if Options.TeleportActive and farmPriority.castle then
    local firePortal, distance = findFirePortalInRange()
    if firePortal and distance <= Options.FirePortalMaxDistance then
        pcall(function()
            teleportToFirePortalAndInteract()
        end)
        task.wait(1.5)
        return true
    end
    
    local foundCastleTarget = findCastleEnemyTarget()
    if foundCastleTarget then
        return true
    else
        pcall(function()
            if useCheckpointCastle then
                executeRemoteWithHashRotation("CastleAction", {
                    ["Check"] = true,
                    ["Event"] = "CastleAction", 
                    ["Action"] = "Join",
                    ["Floor"] = "25"
                })
            else
                executeRemoteWithHashRotation("CastleAction", {
                    ["Check"] = false,
                    ["Event"] = "CastleAction", 
                    ["Action"] = "Join"
                })
            end
        end)
        
        task.wait(0.1)
        
        pcall(function()
            executeRemoteWithHashRotation("CastleAction", {
                ["Type"] = "Gems",
                ["Event"] = "CastleAction",
                ["Action"] = "BuyTicket"
            })
        end)
    end
end
    
if Options.TeleportActive and farmPriority.dungeon then
    local foundDungeonTarget = findDungeonTarget()
    if foundDungeonTarget then
        return true
    end
end

if selectMobFarmOptions.isAutoFarmEnabled and farmPriority.specificMob then
    local foundSpecificTarget = findSpecificMobTarget()
    if foundSpecificTarget then
        return true
    end
end

if selectBossFarmOptions.isAutoBossFarmEnabled and farmPriority.boss then
    local foundBossTarget = findSpecificBossTarget()
    if foundBossTarget then
        return true
    end
end

if Options.TeleportActive and farmPriority.normal then
    local foundNormalTarget = findNormalEnemyTarget()
    if foundNormalTarget then
        return true
    end
end
    
    return false
end

local function getEnemiesInView(maxDistance)
    maxDistance = maxDistance or 2500
    
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    local enemiesContainer = workspace.__Main.__Enemies.Client
    if not enemiesContainer then
        return {}
    end
    
    local enemiesInView = {}
    
    for _, enemy in pairs(enemiesContainer:GetChildren()) do
        if enemy:IsA("Model") then
            local enemyHRP = enemy:FindFirstChild("HumanoidRootPart")
            if enemyHRP then
                local distance = (enemyHRP.Position - humanoidRootPart.Position).Magnitude
                if distance <= maxDistance then
                    table.insert(enemiesInView, {
                        id = enemy.Name,
                        distance = distance,
                        model = enemy
                    })
                end
            end
        end
    end
    
    table.sort(enemiesInView, function(a, b)
        return a.distance < b.distance
    end)
    
    return enemiesInView
end

local function startGlobalFarmThread()
    if globalFarmThread then return end
    
    globalFarmThread = task.spawn(function()
        while true do
            if winterMobFarmOptions.isAutoFarmEnabled or 
               selectMobFarmOptions.isAutoFarmEnabled or
               selectBossFarmOptions.isAutoBossFarmEnabled or
               Options.TeleportActive then
                
                local foundTarget = findPriorityTarget()
                
                if foundTarget and targetSystem.current then
                    pcall(moveToCurrentTarget)
                end
            else
                break
            end
            
            task.wait(0.1)
        end
        
        globalFarmThread = nil
    end)
end

local function stopGlobalFarmThread()
    if globalFarmThread then
        task.cancel(globalFarmThread)
        globalFarmThread = nil
    end
    
    targetSystem.current = nil
    targetSystem.previous = nil
    targetSystem.isChanging = false
    targetSystem.type = "none"
end

local function isAnyFarmActive()
    return winterMobFarmOptions.isAutoFarmEnabled or 
           selectMobFarmOptions.isAutoFarmEnabled or
           selectBossFarmOptions.isAutoBossFarmEnabled or
           Options.TeleportActive
end

--====== FARM: AUTO ATTACK ======

local function getEquippedPetsList()
    local pets = {}
    local success, petsFolder = pcall(function()
        return player.leaderstats.Equips.Pets
    end)
    
    if not success or not petsFolder then 
        return pets 
    end

    for i = 1, 10 do
        local petName = petsFolder:GetAttribute(tostring(i))
        if petName then table.insert(pets, petName) end
    end
    
    return pets
end

local function generateDynamicPetPositions(enemy, isAttack)
    if not enemy then 
        return {} 
    end
    
    local enemyModel
    if enemy.model then
        enemyModel = enemy.model
    else
        enemyModel = enemy
    end
    
    local enemyHRP
    if enemyModel:FindFirstChild("HumanoidRootPart") then
        enemyHRP = enemyModel.HumanoidRootPart
    else
        for _, part in pairs(enemyModel:GetChildren()) do
            if part:IsA("BasePart") then
                enemyHRP = part
                break
            end
        end
    end
    
    if not enemyHRP then 
        return {} 
    end
    
    local basePosition = enemyHRP.Position
    local petPositions = {}
    local pets = getEquippedPetsList()
    
    if #pets == 0 then
        return {}
    end
    
    for i, petName in ipairs(pets) do
        local angle = math.rad((i/#pets)*360)
        local offsetX = math.cos(angle) * (isAttack and 4 or 3)
        local offsetZ = math.sin(angle) * (isAttack and 4 or 3)
        
        petPositions[petName] = basePosition + Vector3.new(offsetX, 0, offsetZ)
    end
    
    return petPositions
end

local function petCombatLoop()
    while isAutoPetActive do
        local enemies = getEnemiesInView(500)
        if #enemies > 0 then
            local nearestEnemy = enemies[1]
            local enemyModel = nearestEnemy.model
            local enemyId = enemyModel.Name
            
            local petPositions = generateDynamicPetPositions(nearestEnemy, true)
            
            if next(petPositions) then
                local args = {
                    ["PetPos"] = petPositions,
                    ["AttackType"] = "All",
                    ["Event"] = "Attack",
                    ["Enemy"] = enemyId
                }
                
                pcall(function()
                    executeRemoteWithHashRotation("Attack", args)
                end)
                task.wait()
            end
        end
        task.wait()
    end
end

local function startAutoPetAttack()
    if isAutoPetActive then 
        return 
    end
    isAutoPetActive = true
    local pets = getEquippedPetsList()
    autoPetThread = task.spawn(petCombatLoop)
end

local function stopAutoPetAttack()
    isAutoPetActive = false
    if autoPetThread then
        task.cancel(autoPetThread)
        autoPetThread = nil
    end
end

local function punchNearestEnemy()
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    local enemiesContainer = workspace.__Main.__Enemies.Client
    if not enemiesContainer then
        return
    end
    
    local nearestEnemy = nil
    local shortestDistance = math.huge
    
    for _, enemy in pairs(enemiesContainer:GetChildren()) do
        if enemy:IsA("Model") then
            local enemyHRP = enemy:FindFirstChild("HumanoidRootPart")
            if enemyHRP then
                local distance = (enemyHRP.Position - humanoidRootPart.Position).Magnitude
                if distance <= 100 and distance < shortestDistance then
                    nearestEnemy = enemy
                    shortestDistance = distance
                end
            end
        end
    end
    
    if nearestEnemy then
        punchAttack(nearestEnemy.Name)
        return true
    else
        return false
    end
end

local function teleportToSpecificCFrame()
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    humanoidRootPart.CFrame = specificCFrame
end



local function startAutoTPToCFrame()
    if tpToCFrameThread then return end
    local active = true
    tpToCFrameThread = task.spawn(function()
        while active do
            pcall(function()
                teleportToSpecificCFrame()
            end)
            
            task.wait(0.1)
        end
    end)
    return function()
        active = false
        task.wait(0.2)
        tpToCFrameThread = nil
    end
end

local function stopAutoTPToCFrame()
    if tpToCFrameThread then
        task.cancel(tpToCFrameThread)
        tpToCFrameThread = nil
    end
end

local function updateSelectedCFrame(island)
    selectedIsland = island
    specificCFrame = islandsCFrames[island]
end

local function isEnemyDefeated(enemy)
    local healthBar = enemy:FindFirstChild("HealthBar")
    if healthBar and healthBar:FindFirstChild("Main") and healthBar.Main:FindFirstChild("Bar") then
        local amountLabel = healthBar.Main.Bar:FindFirstChild("Amount")
        if amountLabel and amountLabel:IsA("TextLabel") then
            local healthText = amountLabel.Text
            local healthValue = tonumber(healthText:match("%d+"))
            return not healthValue or healthValue <= 0
        end
    end
    
    local humanoid = enemy:FindFirstChild("Humanoid")
    if humanoid then
        return humanoid.Health <= 0
    end
    
    return false
end

--====== ARISE SYSTEM ======
local function ariseEnemy(enemyId, times)
    times = times or 3
    
    if not enemyId or type(enemyId) ~= "string" then
        return
    end
    
    for i = 1, times do
        local args = {
            ["Event"] = "EnemyCapture",
            ["Enemy"] = enemyId
        }
        
        executeRemoteWithHashRotation("EnemyCapture", args)
        
        task.wait(0.1)
    end
    
    defeatedEnemies[enemyId] = nil
end

local function scanAndAriseDefeatedEnemies()
    local enemiesContainer = workspace.__Main.__Enemies.Client
    if not enemiesContainer then
        return
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    for enemyId, _ in pairs(defeatedEnemies) do
        local enemy = enemiesContainer:FindFirstChild(enemyId)
        if not enemy then
            defeatedEnemies[enemyId] = nil
        else
            ariseEnemy(enemyId, 3)
        end
    end
    
    for _, enemy in pairs(enemiesContainer:GetChildren()) do
        if enemy:IsA("Model") then
            local enemyId = enemy.Name
            
            if isEnemyDefeated(enemy) and not defeatedEnemies[enemyId] then
                
                defeatedEnemies[enemyId] = true
                                
                ariseEnemy(enemyId, 3)
           end
       end
   end
end


--====== DESTROY SYSTEM ======
local function destroyEnemy(enemyId)
    if not enemyId or type(enemyId) ~= "string" then
        return
    end
    
    local args = {
        ["Event"] = "EnemyDestroy",
        ["Enemy"] = enemyId
    }
    
    executeRemoteWithHashRotation("EnemyDestroy", args)
end

local function destroyAllEnemiesInView()
   local enemiesInView = getEnemiesInView(2500)
   
   if #enemiesInView == 0 then
       return
   end
   
   
   for _, enemy in ipairs(enemiesInView) do
       destroyEnemy(enemy.id)
       task.wait(0.1)
   end
   
end

-- AUTO FUNCTIONS --

local function startAutoArise()
   if Options.AriseActive then return end
   
   Options.AriseActive = true
   
   autoAriseThread = task.spawn(function()
       while Options.AriseActive do
           pcall(function()
               scanAndAriseDefeatedEnemies()
           end)
           
           task.wait(0.1)
       end
   end)
end

local function stopAutoArise()
   Options.AriseActive = false
   
   if autoAriseThread then
       task.cancel(autoAriseThread)
       autoAriseThread = nil
   end
   
   
   defeatedEnemies = {}
end

local function startAutoDestroy()
   if Options.DestroyActive then return end
   
   Options.DestroyActive = true
   
   autoDestroyThread = task.spawn(function()
       while Options.DestroyActive do
           pcall(function()
               destroyAllEnemiesInView()
           end)
           
           task.wait(0.1)
       end
   end)
end

local function stopAutoDestroy()
   Options.DestroyActive = false
   
   if autoDestroyThread then
       task.cancel(autoDestroyThread)
       autoDestroyThread = nil
   end
   
end


--====== MANUAL FARM ======
local function startAutoPunch()
   if autoPunchEnabled then return end
   
   autoPunchEnabled = true
   
   autoPunchThread = task.spawn(function()
       while autoPunchEnabled do
           pcall(function()
               punchNearestEnemy()
           end)
           
           task.wait()
       end
   end)
end

local function stopAutoPunch()
   autoPunchEnabled = false
   
   if autoPunchThread then
       task.cancel(autoPunchThread)
       autoPunchThread = nil
   end
end

local function enableAutoRejoin()
    if autoRejoinConnection then return end
    autoRejoinEnabled = true
    autoRejoinConnection = game:GetService("GuiService").ErrorMessageChanged:Connect(function()
        local msg = game:GetService("GuiService"):GetErrorMessage()
        if msg and msg ~= "" then            
            task.wait(1)
            if autoRejoinEnabled then
                pcall(function()
                    game:GetService("TeleportService"):Teleport(game.PlaceId)
                end)
            end
        end
    end)
end

local function disableAutoRejoin()
    autoRejoinEnabled = false
    if autoRejoinConnection then
        autoRejoinConnection:Disconnect()
        autoRejoinConnection = nil
    end
end

--thanhdeptrai
local Main1 = Tabs.Main:AddSection("Island Travel")
local Main2 = Tabs.Main:AddSection("Auto")
local Main3 = Tabs.Main:AddSection("Hop Server")
local Main4 = Tabs.Main:AddSection("Character")
Main1:AddDropdown("Select Island", {
   Title = "Select Island",
   Values = {"Winter Island", "SoloLeveling Island", "Naruto Island", "OnePiece Island", "BlackClover Island", "Bleach Island",
   "ChainsawMan Island", "Jojo Island", "DragonBall Island", "OPM Island", "Kindama Island"},
   Multi = false,
   Default = "SoloLeveling Island",
   Callback = function(value)
       updateSelectedCFrame(value)
   end
})

Main1:AddToggle("TP To Location", {
   Title = "TP To Island",
   Description = "",
   Default = false,
   Callback = function(state)
       if state then
           pcall(startAutoTPToCFrame)
       else
           pcall(stopAutoTPToCFrame)
       end
   end 
})

Main2:AddToggle("PetsFastAttack", {
    Title = "Pets Fast Attack", 
    Default = false,
    Callback = function(state)
        Options.FastAttackToggle = state
        if state then
        startAutoPetAttack()
     else
        stopAutoPetAttack()
     end
end 
})

Main2:AddToggle("Auto Click [Fast]", {
   Title = "Auto Click [Fast]",
   Description = "Better Auto Click Normal ",
   Default = false,
   Callback = function(state)
       if state then
           pcall(startAutoPunch)
       else
           pcall(stopAutoPunch)
       end
   end 
})

Main2:AddToggle("Auto Arise", {
   Title = "Auto Arise", 
   Description = "Auto Arise All Mobs",
   Default = false,
   Callback = function(state)
       if state then
           pcall(startAutoArise)
       else
           pcall(stopAutoArise)
       end
   end 
})

Main2:AddToggle("Auto Destroy", {
   Title = "Auto Destroy",
   Description = "Auto Destroy All Mobs",
   Default = false,
   Callback = function(state)
       if state then
           pcall(startAutoDestroy)
       else
           pcall(stopAutoDestroy)
       end
   end 
})

Main3:AddButton({
    Title = "Get JobId",
    Callback = function()
        local serverId = game.JobId
        if serverId and serverId ~= "" then
            local joinLink = string.format("Roblox.GameLauncher.joinGameInstance(%d, \"%s\")", game.PlaceId, serverId)
            setclipboard(joinLink)
        else
        end
    end
})

Main3:AddButton({
    Title = "Hop Random Server",
    Callback = function()
        local TeleportService = game:GetService("TeleportService")
        local PlaceId = game.PlaceId
        
        pcall(function()
            TeleportService:Teleport(PlaceId)
        end)
    end
})

Main3:AddButton({
    Title = "Hop Lowest Players",
    Callback = function()
        local TeleportService = game:GetService("TeleportService")
        local PlaceId = game.PlaceId
        
        local function getServerList()
            local servers = {}
            local cursor = ""
            
            while true do
                local success, result = pcall(function()
                    return TeleportService:GetServerList(PlaceId, 100, cursor)
                end)
                
                if not success or not result then
                    break
                end
                
                for _, serverData in ipairs(result.servers) do
                    table.insert(servers, serverData)
                end
                
                cursor = result.nextPageCursor
                if not cursor or cursor == "" then
                    break
                end
            end
            
            return servers
        end
        
        local function findLessPopulatedServer(servers)
            local lessPopulatedServer = nil
            local lowestPlayerCount = math.huge
            
            for _, server in ipairs(servers) do
                if server.playing and server.playing < 3 and server.playing < lowestPlayerCount then
                    lowestPlayerCount = server.playing
                    lessPopulatedServer = server
                end
            end
            
            return lessPopulatedServer
        end
        local servers = getServerList()
        local targetServer = findLessPopulatedServer(servers)
    
        if targetServer then
            pcall(function()
                TeleportService:TeleportToPlaceInstance(PlaceId, targetServer.id)
            end)
        else
            pcall(function()
                TeleportService:Teleport(PlaceId)
            end)
        end
    end
})

local attributesControlEnabled = false
local attributesControlThread = nil
local selectedAttributes = {}

local attributesList = {
    "AutoAttack",
    "AutoClicker",
    "ExtraEquip",
    "ExtraRelic",
    "InstaArite",
    "InstaDestroy",
}

local function setAttributeValue(attributeName, value)
    local player = game:GetService("Players").LocalPlayer
    
    if player and player:FindFirstChild("Attributes") then
        player:SetAttribute(attributeName, value)
    end
end

Main4:AddDropdown("GamepassDropdown", {
    Title = "Select Gamepass",
    Values = attributesList,
    Multi = true,
    Default = {},
}):OnChanged(function(Value)
    selectedAttributes = {}
    for attributeName, State in next, Value do
        if State then
            table.insert(selectedAttributes, attributeName)
        end
    end
    
    if attributesControlEnabled then
        for _, attributeName in ipairs(selectedAttributes) do
            setAttributeValue(attributeName, true)
        end
    end
end)

Main4:AddToggle("GamepassControlToggle", {
    Title = "Unlock Gamepass",
    Default = false,
}):OnChanged(function(state)
    attributesControlEnabled = state
    
    if state then
        for _, attributeName in ipairs(selectedAttributes) do
            setAttributeValue(attributeName, true)
        end
        
        if attributesControlThread then
            task.cancel(attributesControlThread)
        end
        
        attributesControlThread = task.spawn(function()
            while attributesControlEnabled do
                for _, attributeName in ipairs(selectedAttributes) do
                    setAttributeValue(attributeName, true)
                end
                task.wait(1)
            end
        end)
    else
        if attributesControlThread then
            task.cancel(attributesControlThread)
            attributesControlThread = nil
        end
        
        for _, attributeName in ipairs(selectedAttributes) do
            setAttributeValue(attributeName, false)
        end
    end
end)

Main4:AddInput("PlayerSpeedInput", {
    Title = "Player Speed",
    Default = "1",
    Placeholder = "1-999",
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local player = game:GetService("Players").LocalPlayer
        if player and player.leaderstats and player.leaderstats.PlayerStats then
            local playerStats = player.leaderstats.PlayerStats
            
            local numberValue = tonumber(value)
            if numberValue then
                playerStats:SetAttribute("PlayerSpeed", numberValue)
            end
        end
    end
})

Main4:AddInput("ShadowSpeedInput", {
    Title = "Shadow Speed",
    Default = "2",
    Placeholder = "1-999",
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local player = game:GetService("Players").LocalPlayer
        if player and player.leaderstats and player.leaderstats.PlayerStats then
            local playerStats = player.leaderstats.PlayerStats
            
            local numberValue = tonumber(value)
            if numberValue then
                playerStats:SetAttribute("ShadowSpeed", numberValue)
            end
        end
    end
})

Main4:AddInput("ShadowRangeInput", {
    Title = "Shadow Range",
    Default = "3",
    Placeholder = "1-999",
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local player = game:GetService("Players").LocalPlayer
        if player and player.leaderstats and player.leaderstats.PlayerStats then
            local playerStats = player.leaderstats.PlayerStats
            
            local numberValue = tonumber(value)
            if numberValue then
                playerStats:SetAttribute("ShadowRange", numberValue)
            end
        end
    end
})

--====== UI: FARM ======
local Farm1 = Tabs.Auto:AddSection("Setting")
local Farm2 = Tabs.Auto:AddSection("AutoFarm")
local Farm3 = Tabs.Auto:AddSection("Select Mob Farm")
local Farm4 = Tabs.Auto:AddSection("Select Boss Farm")
local Farm5 = Tabs.Auto:AddSection("Select Winter Mob Farm")
Farm1:AddDropdown("MovementMethod", {
    Title = "Farm Method",
    Values = {"TP", "Tween", "Hybrid"},
    Multi = false,
    Default = "TP",
    Callback = function(value)
        Options.MovementMethod = value
    end
 })

Farm1:AddSlider("Tween Speed", {
   Title = "Tween Speed",
   Description = "",
   Default = 150,
   Min = 1,
   Max = 250,
   Rounding = 0,
   Callback = function(value)
       Options.TweenSpeed = value
   end
})

Farm2:AddToggle("Auto Farm", {
    Title = "Auto Farm All Mobs",
    Default = false,
    Callback = function(state)
        Options.TeleportActive = state
        
        if state then
            farmPriority.normal = true
            startGlobalFarmThread()
        else
            farmPriority.normal = false
            
            if not isAnyFarmActive() then
                stopGlobalFarmThread()
            end
        end
    end
})

Farm2:AddToggle("BossFarm", {
    Title = "Auto Farm Boss",
    Description = "Only Farm Boss",
    Default = false,
    Callback = function(state)
        Options.BossFarmActive = state
        
        if state then
            farmPriority.boss = true
            startGlobalFarmThread()
        else
            farmPriority.boss = false
            
            if not isAnyFarmActive() then
                stopGlobalFarmThread()
            end
        end
    end
})


Farm3:AddDropdown("SelectIslandDropdown", {
    Title = "Select Island",
    Values = {"SoloLeveling Island", "Naruto Island", "OnePiece Island", "BlackClover Island", "Bleach Island",
    "ChainsawMan Island", "Jojo Island", "DragonBall Island", "OPM Island", "Kindama Island"},
    Multi = false,
    Default = "SoloLeveling Island",
    Callback = function(value)
        if not islandEnemies[value] then 
            return 
        end
        
        selectMobFarmOptions.selectedIsland = value
        
        local mobOptions = {}
        for _, mob in ipairs(islandEnemies[value] or {}) do
            table.insert(mobOptions, mob.name)
        end
        
        if Solar and Solar.Options and Solar.Options.SelectMobDropdown then
            Solar.Options.SelectMobDropdown:SetValues(mobOptions)
            if #mobOptions > 0 then
                Solar.Options.SelectMobDropdown:SetValue(mobOptions[1])
                
                for _, mob in ipairs(islandEnemies[value]) do
                    if mob.name == mobOptions[1] then
                        selectMobFarmOptions.selectedMobId = mob.id
                        break
                    end
                end
            else
                Solar.Options.SelectMobDropdown:SetValue("")
                selectMobFarmOptions.selectedMobId = nil
            end
        end
    end
})
Farm3:AddDropdown("SelectMobDropdown", {
    Title = "Select Mob",
    Values = {},
    Multi = false,
    Default = nil,
    Callback = function(value)
        if not value or value == "" then
            selectMobFarmOptions.selectedMobId = nil
            return
        end
        
        local selectedMob = nil
        for _, mob in ipairs(islandEnemies[selectMobFarmOptions.selectedIsland] or {}) do
            if mob.name == value then
                selectedMob = mob.id
                break
            end
        end
        
        selectMobFarmOptions.selectedMobId = selectedMob
    end
})

Farm3:AddToggle("SelectMobAutoFarm", {
    Title = "Auto Farm Selected Mob",
    Default = false,
    Callback = function(state)
        selectMobFarmOptions.isAutoFarmEnabled = state
        
        if state then
            farmPriority.specificMob = true
            startGlobalFarmThread()
        else
            farmPriority.specificMob = false
            
            if not isAnyFarmActive() then
                stopGlobalFarmThread()
            end
        end
    end
})

Farm4:AddDropdown("SelectIslandDropdown2", {
    Title = "Select Island",
    Values = {"SoloLeveling Island", "Naruto Island", "OnePiece Island", "BlackClover Island", "Bleach Island",
    "ChainsawMan Island", "Jojo Island", "DragonBall Island", "OPM Island", "Kindama Island"},
    Multi = false,
    Default = "SoloLeveling Island",
    Callback = function(value)
        if not islandBosses[value] then 
            return 
        end
        
        selectBossFarmOptions.selectedIsland = value
        
        local bossOptions = {}
        for _, boss in ipairs(islandBosses[value] or {}) do
            table.insert(bossOptions, boss.name)
        end
        
        pcall(function()
            if Solar and Solar.Options and Solar.Options.SelectBossDropdown then
                Solar.Options.SelectBossDropdown:SetValues(bossOptions)
                Solar.Options.SelectBossDropdown:SetValue({})
                
                if #bossOptions > 0 then
                    local defaultValue = {}
                    defaultValue[bossOptions[1]] = true
                    Solar.Options.SelectBossDropdown:SetValue(defaultValue)
                    
                    selectBossFarmOptions.selectedBossId = {islandBosses[value][1].id}
                else
                    selectBossFarmOptions.selectedBossId = {}
                end
            end
        end)
    end
})
Farm4:AddDropdown("SelectBossDropdown", {
    Title = "Select Boss",
    Values = {},
    Multi = true,
    Default = {},
    Callback = function(Value)
        if type(Value) ~= "table" then
            selectBossFarmOptions.selectedBossId = {}
            return
        end
        
        local SelectedBosses = {}
        for BossName, State in pairs(Value) do
            if State then
                for _, boss in ipairs(islandBosses[selectBossFarmOptions.selectedIsland] or {}) do
                    if boss.name == BossName then
                        table.insert(SelectedBosses, boss.id)
                        break
                    end
                end
            end
        end
        
        if #SelectedBosses == 0 and islandBosses[selectBossFarmOptions.selectedIsland] 
           and #islandBosses[selectBossFarmOptions.selectedIsland] > 0 then
            local firstBoss = islandBosses[selectBossFarmOptions.selectedIsland][1]
            if firstBoss then
                SelectedBosses = {firstBoss.id}
                pcall(function()
                    Solar.Options.SelectBossDropdown:SetValue({[firstBoss.name] = true})
                end)
            end
        end
        
        selectBossFarmOptions.selectedBossId = SelectedBosses
    end
})

Farm4:AddToggle("SelectBossAutoFarm", {
    Title = "Auto Farm Selected Boss",
    Default = false,
    Callback = function(state)
        selectBossFarmOptions.isAutoBossFarmEnabled = state
        
        if state then
            farmPriority.boss = true
            startGlobalFarmThread()
        else
            farmPriority.boss = false
            
            if not isAnyFarmActive() then
                stopGlobalFarmThread()
            end
        end
    end
})
Farm5:AddDropdown("SelectWinterMobDropdown", {
    Title = "Select Mob Winter",
    Values = {},
    Multi = true,
    Default = {},
    Callback = function(Value)
        if type(Value) ~= "table" then
            winterMobFarmOptions.selectedMobIds = {}
            return
        end
        
        local SelectedMobs = {}
        for MobName, State in pairs(Value) do
            if State then
                for _, mob in ipairs(islandEnemies["Winter Island"] or {}) do
                    if mob.name == MobName then
                        table.insert(SelectedMobs, mob.id)
                        break
                    end
                end
            end
        end
        
        if #SelectedMobs == 0 and islandEnemies["Winter Island"] 
           and #islandEnemies["Winter Island"] > 0 then
            local firstMob = islandEnemies["Winter Island"][1]
            if firstMob then
                SelectedMobs = {firstMob.id}
                pcall(function()
                    Solar.Options.SelectWinterMobDropdown:SetValue({[firstMob.name] = true})
                end)
            end
        end
        
        winterMobFarmOptions.selectedMobIds = SelectedMobs
    end
})

local winterMobOptions = {}
for _, mob in ipairs(islandEnemies["Winter Island"] or {}) do
    table.insert(winterMobOptions, mob.name)
end
Solar.Options.SelectWinterMobDropdown:SetValues(winterMobOptions)
if #winterMobOptions > 0 then
    local defaultValue = {}
    defaultValue[winterMobOptions[1]] = true
    Solar.Options.SelectWinterMobDropdown:SetValue(defaultValue)
    
    winterMobFarmOptions.selectedMobIds = {islandEnemies["Winter Island"][1].id}
end

Farm5:AddToggle("SelectWinterMobAutoFarm", {
    Title = "Auto Farm Mob Winter",
    Default = false,
    Callback = function(state)
        winterMobFarmOptions.isAutoFarmEnabled = state
        
        if state then
            farmPriority.winter = true
            startGlobalFarmThread()
        else
            farmPriority.winter = false
            
            if not isAnyFarmActive() then
                stopGlobalFarmThread()
            end
        end
    end
})

local Dungeon1 = Tabs.Dungeon:AddSection("Dungeon Castle")
local Dungeon3 = Tabs.Dungeon:AddSection("Dungeon")
local Dungeon4 = Tabs.Dungeon:AddSection("Dungeon Setting")

Dungeon1:AddToggle("AutoJoinCheckpointCastle", {
    Title = "Auto Join Checkpoint Castle",
    Description = "Join checkpoint castle room 25",
    Default = false,
    Callback = function(state)
        useCheckpointCastle = state
    end
})
Dungeon1:AddToggle("AutoDungeonRed", {
    Title = "Auto Dungeon Castle",
    Description = "Infinity Castle",
    Default = false,
    Callback = function(state)
        Options.TeleportActive = state
        
        if state then
            farmPriority.castle = true
            startGlobalFarmThread()
        else
            farmPriority.castle = false
            
            if not isAnyFarmActive() then
                stopGlobalFarmThread()
            end
        end
    end
})

Dungeon1:AddInput("DungeonRejoinFloor", {
    Title = "Input Room Dungeon",
    Default = "30",
    Placeholder = "",
    Callback = function(value)
        local floor = tonumber(value)
        if floor and floor >= 1 and floor <= 100 then
            dungeonRejoinFloor = floor
        else
        end
    end
})

Dungeon1:AddToggle("AutoRejoinDungeon", {
    Title = "Auto Leave Dungeon",
    Default = false,
    Callback = function(state)
        autoRejoinDungeonEnabled = state
        
        if state then
            autoRejoinDungeonThread = task.spawn(function()
                local attemptCount = 0
                local maxAttempts = 10
                local success = false
                
                while autoRejoinDungeonEnabled and not success do
                    local checkResult, floorText = pcall(function()
                        local player = game:GetService("Players").LocalPlayer
                        if player and player.PlayerGui and player.PlayerGui:FindFirstChild("Hud") then
                            local hudGui = player.PlayerGui.Hud
                            if hudGui:FindFirstChild("UpContanier") and hudGui.UpContanier:FindFirstChild("Room") then
                                local roomLabel = hudGui.UpContanier.Room
                                if roomLabel then
                                    return roomLabel.Text
                                end
                            end
                        end
                        return nil
                    end)
                    
                    if checkResult and floorText then
                        if floorText == "Floor: " .. dungeonRejoinFloor .. "/100" then
                            while attemptCount < maxAttempts and not success and autoRejoinDungeonEnabled do
                                attemptCount = attemptCount + 1                                    
                                local teleportSuccess = pcall(function()
                                    game:GetService("TeleportService"):Teleport(87039211657390)
                                end)
                                
                                if teleportSuccess then
                                    success = true
                                else
                                    task.wait(2)
                                end
                            end
                            
                            if not success and autoRejoinDungeonEnabled then
                                autoRejoinDungeonEnabled = false
                                if Solar.Options.AutoRejoinDungeon then
                                    Solar.Options.AutoRejoinDungeon:SetValue(false)
                                end
                            end
                        end
                    end
                    
                    task.wait(1)
                end
            end)
            
        else
            if autoRejoinDungeonThread then
                task.cancel(autoRejoinDungeonThread)
                autoRejoinDungeonThread = nil
            end
        end
    end
})

Dungeon3:AddToggle("AutoCreateDungeon", {
    Title = "Auto Join Dungeon",
    Description = "Join all rank dungeon",
    Default = false,
    Callback = function(state)
        if state then
            task.spawn(function()
                while state do
                    local serverContainer = workspace.__Main.__Enemies.Server
                    local hasDungeonEnemy = false
                    
                    if serverContainer then
                        for _, part in pairs(serverContainer:GetChildren()) do
                            if part:IsA("BasePart") then
                                local enemyType = part:GetAttribute("Type")
                                local hp = part:GetAttribute("HP") or 0
                                
                                if enemyType == "Dungeon" and hp > 0 then
                                    hasDungeonEnemy = true
                                    break
                                end
                            end
                        end
                    end
                    
                    if not hasDungeonEnemy then
                        executeRemoteWithHashRotation("DungeonAction", {
                            ["Type"] = "Gems",
                            ["Event"] = "DungeonAction",
                            ["Action"] = "BuyTicket"
                        })
                        
                        task.wait(0.1)
                        
                        executeRemoteWithHashRotation("DungeonAction", {
                            ["Event"] = "DungeonAction",
                            ["Action"] = "Create"
                        })
                        
                        task.wait(0.1)
                        
                        executeRemoteWithHashRotation("DungeonAction", {
                            ["Dungeon"] = 5596146126,
                            ["Event"] = "DungeonAction",
                            ["Action"] = "Start"
                        })
                    else
                        break
                    end
                    
                    task.wait(1)
                end
            end)
        end
    end
})

local dungeonFinderConfig = {
    enabled = false,
    selectedRanks = {}
}

local function checkAndCreateDungeon()
    if not workspace.__Main.__Dungeon or not workspace.__Main.__Dungeon:FindFirstChild("Dungeon") then
        return false
    end
    
    local dungeonPart = workspace.__Main.__Dungeon.Dungeon
    local currentRank = dungeonPart:GetAttribute("DungeonRank")
    
    if not currentRank then
        return false
    end
    
    for _, selectedRank in ipairs(dungeonFinderConfig.selectedRanks) do
        if currentRank == selectedRank then
            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            
            local direction = (dungeonPart.Position - humanoidRootPart.Position).Unit
            local targetPosition = dungeonPart.Position - direction * 10
            local targetCFrame = CFrame.lookAt(targetPosition, dungeonPart.Position)
            
            humanoidRootPart.CFrame = targetCFrame
            task.wait(0.5)
            executeRemoteWithHashRotation("DungeonAction", {
                ["Type"] = "Gems",
                ["Event"] = "DungeonAction",
                ["Action"] = "BuyTicket"
            })
            task.wait(0.1)
            executeRemoteWithHashRotation("DungeonAction", {
                ["Event"] = "DungeonAction",
                ["Action"] = "Create"
            })
            task.wait(0.1)
            executeRemoteWithHashRotation("DungeonAction", {
                ["Dungeon"] = 5596146126,
                ["Event"] = "DungeonAction",
                ["Action"] = "Start"
            })
            
            return true
        end
    end
    
    return false
end
local dungeonFinderThread = nil

Dungeon3:AddToggle("AutoDungeonFinder", {
    Title = "Auto Join Selected Rank",
    Default = false,
    Callback = function(state)
        dungeonFinderConfig.enabled = state
        
        if state then
            if dungeonFinderThread then
                pcall(function()
                    task.cancel(dungeonFinderThread)
                end)
            end
            
            dungeonFinderThread = task.spawn(function()
                while dungeonFinderConfig.enabled do
                    local success = checkAndCreateDungeon()
                    
                    if success then
                        dungeonFinderConfig.enabled = false
                        if Solar.Options.AutoDungeonFinder then
                            Solar.Options.AutoDungeonFinder:SetValue(false)
                        end
                        break
                    end
                    
                    task.wait(1)
                end
            end)
        else
            if dungeonFinderThread then
                pcall(function()
                    task.cancel(dungeonFinderThread)
                end)
                dungeonFinderThread = nil
            end
        end
    end
})

Dungeon4:AddDropdown("DungeonRankSelector", {
    Title = "Select Dungeon Rank",
    Values = {"E", "D", "C", "B", "A", "S", "SS"},
    Multi = true,
    Default = {},
    Callback = function(Value)
        dungeonFinderConfig.selectedRanks = {}
        
        for rankName, isSelected in pairs(Value) do
            if isSelected then
                local numericRank = levelMap[rankName]
                if numericRank then
                    table.insert(dungeonFinderConfig.selectedRanks, numericRank)
                end
            end
        end
    end
})

Dungeon4:AddToggle("AutoDungeonNormal", {
    Title = "Auto Dungeon",
    Description = "Auto farm mobs dungeon",
    Default = false,
    Callback = function(state)
        Options.TeleportActive = state
        
        if state then
            farmPriority.dungeon = true
            startGlobalFarmThread()
        else
            farmPriority.dungeon = false
            
            if not isAnyFarmActive() then
                stopGlobalFarmThread()
            end
        end
    end
})

Dungeon4:AddToggle("AutoTeleportDungeonEnd", {
    Title = "Auto Leave Dungeon",
    Description = "Leave when finish dungeon",
    Default = false,
    Callback = function(state)
        local active = state
        
        if autoTeleportDungeonEndThread then
            local oldThread = autoTeleportDungeonEndThread
            autoTeleportDungeonEndThread = nil
            
            pcall(function()
                task.cancel(oldThread)
            end)
        end
        
        if active then
            autoTeleportDungeonEndThread = task.spawn(function()
                while active do
                    local info = updateDungeonInfoCache()
                    
                    if info.hasText and info.timeLeft <= 15 then
                        pcall(function()
                            game:GetService("TeleportService"):Teleport(87039211657390)
                        end)
                        task.wait(5)
                        break
                    end
                    
                    if not Solar.Options.AutoTeleportDungeonEnd.Value then
                        active = false
                        break
                    end
                    
                    task.wait(0.2)
                end
                
                if autoTeleportDungeonEndThread == task.current() then
                    autoTeleportDungeonEndThread = nil
                end
            end)
        end
    end
})

local autoRestartDungeonThread = nil
Dungeon4:AddToggle("AutoRestartDungeon", {
    Title = "Auto Replay Dungeon",
    Description = "Replay when finish dungeon",
    Default = false,
    Callback = function(state)
        local active = state
        
        if autoRestartDungeonThread then
            local oldThread = autoRestartDungeonThread
            autoRestartDungeonThread = nil
            
            pcall(function()
                task.cancel(oldThread)
            end)
        end
        
        if active then
            autoRestartDungeonThread = task.spawn(function()
                while active do
                    local info = updateDungeonInfoCache()
                    
                    if info.hasText and info.timeLeft <= 15 then
                        executeRemoteWithHashRotation("DungeonAction", {
                            ["Type"] = "Gems",
                            ["Event"] = "DungeonAction",
                            ["Action"] = "BuyTicket"
                        })
                        
                        task.wait(0.1)
                        
                        executeRemoteWithHashRotation("DungeonAction", {
                            ["Event"] = "DungeonAction",
                            ["Action"] = "Create"
                        })
                        
                        task.wait(0.1)
                        
                        executeRemoteWithHashRotation("DungeonAction", {
                            ["Dungeon"] = 5596146126,
                            ["Event"] = "DungeonAction",
                            ["Action"] = "Start"
                        })
                        
                        task.wait(20)
                        break
                    end
                    
                    if not Solar.Options.AutoRestartDungeon.Value then
                        active = false
                        break
                    end
                    
                    task.wait(0.2)
                end
                
                if autoRestartDungeonThread == task.current() then
                    autoRestartDungeonThread = nil
                end
            end)
        end
    end
})
--====== UI: SHOP ======
local Shop1 = Tabs.Shop:AddSection("Shop")
local Shop2 = Tabs.Shop:AddSection("Weapon Upgrade")

Shop1:AddDropdown("ShopSelector", {
    Title = "Select Shop",
    Values = shopDisplayValues,
    Multi = false,
    Default = "SoloLeveling Shop",
    Callback = function(displayValue)
        if not shopInternalNames or not shopInternalNames[displayValue] then return end
        local internalValue = shopInternalNames[displayValue]
        selectedShop = internalValue
        local itemDisplays = getItemDisplayNames(internalValue) or {}
        if Solar and Solar.Options and Solar.Options.ItemSelector then
            Solar.Options.ItemSelector:SetValues(itemDisplays)
            Solar.Options.ItemSelector:SetValue(itemDisplays[1] or "")
        end
    end
})

Shop1:AddDropdown("ItemSelector", {
    Title = "Select Item",
    Values = getItemDisplayNames(selectedShop),
    Multi = false,
    Default = selectedItemDisplay,
    Callback = function(displayValue)
        selectedItemDisplay = displayValue
        selectedItemInternal = findInternalItemName(selectedShop, displayValue)
    end
})
local selectedBuyAmount = 1
Shop1:AddDropdown("BuyAmountDropdown", {
    Title = "Select Amount Weapon",
    Description = "Select amount to buy",
    Values = {"x1", "x2", "x5", "x10", "x25", "x50", "x100"},
    Multi = false,
    Default = "x1",
    Callback = function(value)
        local amountNumber = tonumber(string.match(value, "x(%d+)"))
        if amountNumber then
            selectedBuyAmount = amountNumber
        else
            selectedBuyAmount = 1
        end
    end
})
local autoBuyThread = nil

Shop1:AddToggle("BuyItem", {
    Title = "Auto Buy Selected Item",
    Default = false,
    Callback = function(state)
        if state then
            autoBuyThread = task.spawn(function()
                while task.wait(0.1) do
                    if not Solar.Options.BuyItem.Value then
                        break
                    end
                    executeRemoteWithHashRotation("ItemShopAction", {
                        ["Shop"] = selectedShop,
                        ["Action"] = "Buy",
                        ["Amount"] = selectedBuyAmount,
                        ["Event"] = "ItemShopAction",
                        ["Item"] = selectedItemInternal
                    })                  
                end
            end)
        else
            if autoBuyThread then
                task.cancel(autoBuyThread)
                autoBuyThread = nil
            end
        end
    end
})

Shop2:AddInput("WeaponUpgradeInput", {
    Title = "Weapon Name",
    Default = "",
    Placeholder = "Enter Weapon Name (e.g. Spiked Maul, SpikeMace)",
    Callback = function(value)
        local function findWeaponName(searchValue)
            for _, shopCategory in pairs(shopItems) do
                for _, item in ipairs(shopCategory) do
                    if item.displayName:lower():find(searchValue:lower()) or 
                       item.internalName:lower():find(searchValue:lower()) then
                        return item.internalName
                    end
                end
            end
            return nil
        end
        
        local weaponName = findWeaponName(value)
        
        if weaponName then
            weaponUpgradeInfo.weaponName = weaponName
        else
            weaponUpgradeInfo.weaponName = ""
        end
    end
})

Shop2:AddDropdown("WeaponUpgradeLevel", {
    Title = "Upgrade to Rank",
    Values = {"D", "C", "B", "A", "S", "SS"},
    Multi = false,
    Default = nil,
    Callback = function(value)
        weaponUpgradeInfo.targetLevel = levelMap[value] or 2
    end
})
 
Shop2:AddToggle("AutoWeaponUpgrade", {
Title = "Auto Upgrade Weapon",
Default = false,
Callback = function(state)
    weaponUpgradeInfo.autoUpgradeEnabled = state
    
    if state then
        task.spawn(function()
            while weaponUpgradeInfo.autoUpgradeEnabled do
                if weaponUpgradeInfo.weaponName ~= "" then
                    local function upgradeWeapon(weaponType, level)
                        local player = game:GetService("Players").LocalPlayer
                        local inventory = player.leaderstats.Inventory.Weapons
                        
                        local weaponsToUpgrade = {}
                        
                        for _, weapon in pairs(inventory:GetChildren()) do
                            if weapon.Name:match(weaponType) then
                                local currentLevel = weapon:GetAttribute("Level") or 1
                                
                                if currentLevel == level - 1 then
                                    table.insert(weaponsToUpgrade, weapon.Name)
                                end
                            end
                        end
                        
                        if #weaponsToUpgrade == 0 then
                            return
                        end
                        
                        local selectedWeapons = {}
                        for i = 1, math.min(3, #weaponsToUpgrade) do
                            table.insert(selectedWeapons, weaponsToUpgrade[i])
                        end
                        executeRemoteWithHashRotation("UpgradeWeapon", {
                            ["Type"] = weaponType,
                            ["Auto"] = true,
                            ["BuyType"] = "Gems", 
                            ["Event"] = "UpgradeWeapon", 
                            ["Level"] = level,
                            ["Weapons"] = selectedWeapons
                        })
                    end
                    upgradeWeapon(weaponUpgradeInfo.weaponName, weaponUpgradeInfo.targetLevel)
                end
                task.wait(0.1)
            end
        end)
    end
end
})


local webhookConfig = {
    url = "",
    userId = "",
    pingEnabled = false
}
local webhookDungeonThread = nil
local Webhook1 = Tabs.Webhook:AddSection("Webhook Dungeon")
Webhook1:AddInput("WebhookURL", {
    Title = "Webhook URL",
    Default = webhookConfig.url,
    Placeholder = "",
    Numeric = false,
    Finished = true,
    Callback = function(value)
        webhookConfig.url = value
    end
})
Webhook1:AddInput("WebhookUserID", {
    Title = "Discord User ID",
    Default = webhookConfig.userId,
    Placeholder = "123456789",
    Numeric = true,
    Finished = true,
    Callback = function(value)
        webhookConfig.userId = value
    end
})

local function sendWebhookWithPing(data)
    if webhookConfig.pingEnabled and webhookConfig.userId ~= "" then
        local notificationData = {
            ["content"] = "<@" .. webhookConfig.userId .. ">",
            ["embeds"] = data.embeds or {{
                ["title"] = "Solar Hub Notification",
                ["description"] = "Dungeon Completed",
                ["color"] = 10181046
            }}
        }
        
        local HttpService = game:GetService("HttpService")
        local jsonData = HttpService:JSONEncode(notificationData)
        
        if syn and syn.request then
            syn.request({
                Url = webhookConfig.url,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = jsonData
            })
        elseif request then
            request({
                Url = webhookConfig.url,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = jsonData
            })
        elseif http and http.request then
            http.request({
                Url = webhookConfig.url,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = jsonData
            })
        elseif http_request then
            http_request({
                Url = webhookConfig.url,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = jsonData
            })
        end
    else
        local HttpService = game:GetService("HttpService")
        local jsonData = HttpService:JSONEncode(data)
        
        if syn and syn.request then
            syn.request({
                Url = webhookConfig.url,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = jsonData
            })
        elseif request then
            request({
                Url = webhookConfig.url,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = jsonData
            })
        elseif http and http.request then
            http.request({
                Url = webhookConfig.url,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = jsonData
            })
        elseif http_request then
            http_request({
                Url = webhookConfig.url,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = jsonData
            })
        end
    end
end

local dungeonWebhookState = {
    hasPingedCurrentDungeon = false
}

Webhook1:AddToggle("EnableWebhook", {
    Title = "Enable Webhook",
    Default = false,
    Callback = function(state)
        webhookConfig.enabled = state
        
        dungeonWebhookState.hasPingedCurrentDungeon = false
        
        if state then
            if webhookDungeonThread then
                task.cancel(webhookDungeonThread)
            end
            
            webhookDungeonThread = task.spawn(function()
                local dungeonStarted = false
                
                while webhookConfig.enabled do
                    pcall(function()
                        local player = game.Players.LocalPlayer
                        if not player or not player.PlayerGui then return end
                        
                        if not dungeonStarted and 
                           player.PlayerGui:FindFirstChild("Hud") and 
                           player.PlayerGui.Hud:FindFirstChild("UpContanier") and
                           player.PlayerGui.Hud.UpContanier:FindFirstChild("TimeLeft") then
                            
                            local timeLeftText = player.PlayerGui.Hud.UpContanier.TimeLeft.Text
                            
                            if timeLeftText and string.find(timeLeftText, "Time Left") then
                                dungeonStarted = true
                                startTime = os.time()
                            end
                        end
                        
                        if dungeonStarted then
                            if player.PlayerGui:FindFirstChild("Hud") and 
                               player.PlayerGui.Hud:FindFirstChild("UpContanier") and
                               player.PlayerGui.Hud.UpContanier:FindFirstChild("DungeonInfo") and
                               player.PlayerGui.Hud.UpContanier.DungeonInfo:FindFirstChild("TextLabel") then
                                
                                local dungeonText = player.PlayerGui.Hud.UpContanier.DungeonInfo.TextLabel.Text
                                
                                if dungeonText and string.find(dungeonText, "Dungeon Ends in") then
                                    if not dungeonWebhookState.hasPingedCurrentDungeon then
                                        local endTime = os.time()
                                        local elapsedTime = endTime - startTime
                                        local hours = math.floor(elapsedTime / 3600)
                                        local minutes = math.floor((elapsedTime % 3600) / 60)
                                        local seconds = elapsedTime % 60
                                        local formattedTime = string.format("%02d:%02d:%02d", hours, minutes, seconds)
                                        
                                        local coinsText = "N/A"
                                        local gemsText = "N/A"
                                        local expText = "N/A"
                                        
                                        if player.PlayerGui.Hud.BottomContainer:FindFirstChild("Coins") then
                                            coinsText = player.PlayerGui.Hud.BottomContainer.Coins.Text
                                        end
                                        
                                        if player.PlayerGui.Hud.BottomContainer:FindFirstChild("Gems") then
                                            gemsText = player.PlayerGui.Hud.BottomContainer.Gems.Text
                                        end
                                        
                                        if player.PlayerGui.Hud.BottomContainer:FindFirstChild("ExpBar") and 
                                           player.PlayerGui.Hud.BottomContainer.ExpBar:FindFirstChild("ExpText") then
                                            expText = player.PlayerGui.Hud.BottomContainer.ExpBar.ExpText.Text
                                        end
                                        
                                        local data = {
                                            ["embeds"] = {{
                                                ["title"] = "Arise Crossover",
                                                ["color"] = 10181046,
                                                ["fields"] = {
                                                    {
                                                        ["name"] = "Username: || " .. player.Name .. " ||",
                                                        ["value"] = expText,
                                                        ["inline"] = false
                                                    },
                                                    {
                                                        ["name"] = " Cash",
                                                        ["value"] = coinsText,
                                                        ["inline"] = false
                                                    },
                                                    {
                                                        ["name"] = " Gems",
                                                        ["value"] = gemsText,
                                                        ["inline"] = true
                                                    },
                                                    {
                                                        ["name"] = " Dungeon Completed",
                                                        ["value"] = formattedTime,
                                                        ["inline"] = false
                                                    }
                                                },
                                                ["footer"] = {
                                                    ["text"] = "Solar Hub  " .. os.date("%I:%M %p")
                                                }
                                            }}
                                        }
                                        
                                        sendWebhookWithPing(data)
                                        
                                        dungeonWebhookState.hasPingedCurrentDungeon = true
                                        
                                        webhookConfig.enabled = false
                                        if Solar and Solar.Options and Solar.Options.EnableWebhook then
                                            Solar.Options.EnableWebhook:SetValue(false)
                                        end
                                    end
                                end
                            end
                            
                            if not (player.PlayerGui:FindFirstChild("Hud") and 
                                    player.PlayerGui.Hud:FindFirstChild("UpContanier") and
                                    player.PlayerGui.Hud.UpContanier:FindFirstChild("TimeLeft")) then
                                dungeonStarted = false
                            end
                        end
                    end)
                    
                    task.wait(1)
                end
            end)
        else
            if webhookDungeonThread then
                task.cancel(webhookDungeonThread)
                webhookDungeonThread = nil
            end
        end
    end
})

Webhook1:AddToggle("EnableWebhookPing", {
    Title = "Webhook Ping",
    Default = false,
    Callback = function(state)
        webhookConfig.pingEnabled = state
        
        if state and webhookConfig.userId == "" then
            return false
        end
    end
})

Webhook1:AddButton({
    Title = "Test Webhook",
    Callback = function()
        local player = game.Players.LocalPlayer
        if not player then return end
        
        local data = {
            ["embeds"] = {{
                ["title"] = "Arise Crossover",
                ["description"] = "Test Webhook",
                ["color"] = 10181046,
                ["footer"] = {
                    ["text"] = "Solar Hub  " .. os.date("%I:%M %p")
                }
            }}
        }
        
        pcall(function()
            sendWebhookWithPing(data)
        end)
    end
})

Tabs.Settings:AddToggle("AutoRejoin", {
    Title = "Auto Rejoin",
    Description = "Auto rejoin when disconnect",
    Default = false,
    Callback = function(state)
        if state then
            enableAutoRejoin()
        else
            disableAutoRejoin()
        end
    end
})
Tabs.Settings:AddToggle("ToggleNameDisplay", {
    Title = "Auto HideName",
    Default = true,
    Callback = function(state)
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        
        for _, v in pairs(character:GetDescendants()) do
            if v:IsA("BillboardGui") then
                v.Enabled = not state
            end
        end
    end 
})
Tabs.Settings:AddToggle("BlackScreenToggle", {
    Title = "Black Screen",
    Default = false,
}):OnChanged(function(state)
    local blackScreenEnabled = state
    local player = game:GetService("Players").LocalPlayer
    
    if game:GetService("CoreGui"):FindFirstChild("BlackScreenOverlay") then
        game:GetService("CoreGui"):FindFirstChild("BlackScreenOverlay"):Destroy()
    end
    
    if player:FindFirstChild("PlayerGui"):FindFirstChild("BlackScreenOverlay") then
        player:FindFirstChild("PlayerGui"):FindFirstChild("BlackScreenOverlay"):Destroy()
    end
    
    if blackScreenEnabled then
        local blackScreenGui = Instance.new("ScreenGui")
        blackScreenGui.Name = "BlackScreenOverlay"
        blackScreenGui.ResetOnSpawn = false
        blackScreenGui.DisplayOrder = 0
        blackScreenGui.IgnoreGuiInset = true
        
        local success = pcall(function()
            blackScreenGui.Parent = game:GetService("CoreGui")
        end)
        
        if not success then
            blackScreenGui.Parent = player:WaitForChild("PlayerGui")
        end
        
        local frame = Instance.new("Frame")
        frame.Name = "BlackFrame"
        frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        frame.BorderSizePixel = 0
        frame.Position = UDim2.new(0, 0, 0, 0)
        frame.Size = UDim2.new(1, 0, 1, 0)
        frame.ZIndex = 0
        frame.Parent = blackScreenGui
        
        local useLogoOption = true
        if useLogoOption then
            local logo = Instance.new("ImageLabel")
            logo.BackgroundTransparency = 1
            logo.Image = "rbxassetid://94361536997609"
            logo.Size = UDim2.new(0, 200, 0, 200)
            logo.Position = UDim2.new(0.5, 0, 0.4, 0)
            logo.AnchorPoint = Vector2.new(0.5, 0.5)
            logo.ZIndex = 2
            logo.Parent = blackScreenGui
        end
        
        local hubText = Instance.new("TextLabel")
        hubText.BackgroundTransparency = 1
        hubText.Font = Enum.Font.GothamBold
        hubText.Text = "SOLAR HUB"
        hubText.TextColor3 = Color3.fromRGB(255, 255, 255)
        hubText.TextSize = 40
        hubText.Position = useLogoOption and UDim2.new(0.5, 0, 0.5, 20) or UDim2.new(0.5, 0, 0.45, 0)
        hubText.AnchorPoint = Vector2.new(0.5, 0.5)
        hubText.Size = UDim2.new(0, 300, 0, 50)
        hubText.ZIndex = 2
        hubText.Parent = blackScreenGui
        
        local discordText = Instance.new("TextLabel")
        discordText.BackgroundTransparency = 1
        discordText.Font = Enum.Font.Gotham
        discordText.Text = "https://discord.gg/hnnWQPCHDC"
        discordText.TextColor3 = Color3.fromRGB(200, 200, 200)
        discordText.TextSize = 18
        discordText.Position = useLogoOption and UDim2.new(0.5, 0, 0.5, 60) or UDim2.new(0.5, 0, 0.5, 20)
        discordText.AnchorPoint = Vector2.new(0.5, 0)
        discordText.Size = UDim2.new(0, 300, 0, 30)
        discordText.ZIndex = 2
        discordText.Parent = blackScreenGui
        
        local toggleButton = Instance.new("TextButton")
        toggleButton.Name = "DisableButton"
        toggleButton.Size = UDim2.new(0, 220, 0, 45)
        toggleButton.Position = UDim2.new(0.5, 0, 0.08, 0)
        toggleButton.AnchorPoint = Vector2.new(0.5, 0)
        toggleButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
        toggleButton.BorderSizePixel = 0
        toggleButton.Font = Enum.Font.GothamBold
        toggleButton.Text = "DISABLE BLACK SCREEN"
        toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        toggleButton.TextSize = 16
        toggleButton.ZIndex = 10
        toggleButton.Parent = blackScreenGui
        
        local buttonCorner = Instance.new("UICorner")
        buttonCorner.CornerRadius = UDim.new(0, 8)
        buttonCorner.Parent = toggleButton
        
        local buttonStroke = Instance.new("UIStroke")
        buttonStroke.Color = Color3.fromRGB(255, 80, 80)
        buttonStroke.Thickness = 2
        buttonStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
        buttonStroke.Parent = toggleButton
        
        local shadowFrame = Instance.new("Frame")
        shadowFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        shadowFrame.BorderSizePixel = 0
        shadowFrame.Size = UDim2.new(1, 0, 1, 0)
        shadowFrame.Position = UDim2.new(0, 0, 0, 2)
        shadowFrame.ZIndex = 9
        shadowFrame.Parent = toggleButton
        
        local shadowCorner = Instance.new("UICorner")
        shadowCorner.CornerRadius = UDim.new(0, 8)
        shadowCorner.Parent = shadowFrame
        
        toggleButton.MouseEnter:Connect(function()
            toggleButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        end)
        
        toggleButton.MouseLeave:Connect(function()
            toggleButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
        end)
        
        toggleButton.MouseButton1Click:Connect(function()
            blackScreenGui:Destroy()
            
            pcall(function()
                if Solar and Solar.Options and Solar.Options.BlackScreenToggle then
                    Solar.Options.BlackScreenToggle:SetValue(false)
                end
            end)
        end)
        
        game:GetService("RunService").RenderStepped:Connect(function()
            if not blackScreenGui or not blackScreenGui.Parent then
                return
            end
            
            if blackScreenGui.DisplayOrder ~= 0 then
                blackScreenGui.DisplayOrder = 0
            end
            
            for _, guiObject in pairs(game:GetService("CoreGui"):GetChildren()) do
                if guiObject:IsA("ScreenGui") and guiObject ~= blackScreenGui then
                    if guiObject.DisplayOrder < 10 then
                        guiObject.DisplayOrder = 10
                    end
                end
            end
            
            for _, guiObject in pairs(player.PlayerGui:GetChildren()) do
                if guiObject:IsA("ScreenGui") and guiObject ~= blackScreenGui then
                    if guiObject.DisplayOrder < 10 then
                        guiObject.DisplayOrder = 10
                    end
                end
            end
        end)
    end
end)

local autoExecuteEnabled = false
local hiddenUI = game:GetService("CoreGui")

local function saveAutoExecFlag()
    if hiddenUI:FindFirstChild("SolarHub_AutoExec") then
        hiddenUI:FindFirstChild("SolarHub_AutoExec"):Destroy()
    end
    
    local flagGui = Instance.new("ScreenGui")
    flagGui.Name = "SolarHub_AutoExec"
    flagGui.ResetOnSpawn = false
    flagGui.Enabled = false
    
    local statusFlag = Instance.new("BoolValue")
    statusFlag.Name = "Enabled"
    statusFlag.Value = true
    statusFlag.Parent = flagGui
    
    local scriptUrl = Instance.new("StringValue")
    scriptUrl.Name = "ScriptURL"
    scriptUrl.Value = "https://raw.githubusercontent.com/Solar00001/SolarHub1/main/SolarHub1.lua"
    scriptUrl.Parent = flagGui
    
    pcall(function()
        flagGui.Parent = hiddenUI
    end)
end

if _G.SolarHubInitialized == nil then
    _G.SolarHubInitialized = true
    _G.SolarHubExecuted = false
end

Tabs.Settings:AddToggle("AutoExecuteToggle", {
    Title = "Auto Execute",
    Default = false,
}):OnChanged(function(state)
    autoExecuteEnabled = state

    if state then
        saveAutoExecFlag()
        if queue_on_teleport then
            queue_on_teleport([[
                if not _G.SolarHubExecuted then
                    _G.SolarHubExecuted = true
                    task.spawn(function()
                        repeat wait() until game:IsLoaded() and game.Players.LocalPlayer
                        loadstring(game:HttpGet("https://raw.githubusercontent.com/Solar00001/SolarHub1/main/SolarHub1.lua"))()
                    end)
                end
            ]])
        end
    else
        if hiddenUI then
            local gui = hiddenUI:FindFirstChild("SolarHub_AutoExec")
            if gui then
                gui:Destroy()
            end
        end
        _G.SolarHubExecuted = false
    end
end)

local function initAutoExecute()
    if _G.SolarHubExecuted then
        return
    end

    local existingFlag = hiddenUI:FindFirstChild("SolarHub_AutoExec")
    if existingFlag then
        local enabledValue = false
        pcall(function()
            if existingFlag:FindFirstChild("Enabled") then
                local enabledInstance = existingFlag:FindFirstChild("Enabled")
                if enabledInstance:IsA("BoolValue") then
                    enabledValue = enabledInstance.Value
                end
            elseif existingFlag:GetAttribute("Enabled") ~= nil then
                enabledValue = existingFlag:GetAttribute("Enabled")
            end
        end)
        if enabledValue == true then
            task.wait(1)
            if Solar.Options and Solar.Options.AutoExecuteToggle then
                Solar.Options.AutoExecuteToggle:SetValue(true)
            end
        end
    end
end

Tabs.Settings:AddToggle("MinimizeToggle", {
    Title = "Toggle Minimize Button",
    Default = true,
}):OnChanged(function(state)
    Solar.Minimizer.Visible = state
end)
--====== SAVE & LOAD CONFIG ======
SaveManager:SetLibrary(Solar)
InterfaceManager:SetLibrary(Solar)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("SolarHub")
SaveManager:SetFolder("SolarHub/AriseCrossover")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab(1)
SaveManager:LoadAutoloadConfig()
--===========================t sau SaveManager:LoadAutoloadConfig()  khi ng toggle AutoFarm
task.spawn(function()
    task.wait(5)
    if Solar.Options.AutoDungeonNormal and Solar.Options.AutoDungeonNormal.Value then
        Options.TeleportActive = true
        farmPriority.dungeon = true
    end

    if Solar.Options.AutoDungeonRankTest and Solar.Options.AutoDungeonRankTest.Value then
        Options.TeleportActive = true
        farmPriority.dungeon = true
    end

    if Solar.Options["Auto Dungeon Red"] and Solar.Options["Auto Dungeon Red"].Value then
        Options.TeleportActive = true
        farmPriority.castle = true
    end
    
    if Solar.Options["Auto Farm"] and Solar.Options["Auto Farm"].Value then
        Options.TeleportActive = true
        farmPriority.normal = true
    end
    
    if Solar.Options["BossFarm"] and Solar.Options["BossFarm"].Value then
        Options.BossFarmActive = true
        farmPriority.boss = true
    end
    
    if Solar.Options["SelectMobAutoFarm"] and Solar.Options["SelectMobAutoFarm"].Value then
        selectMobFarmOptions.isAutoFarmEnabled = true
        farmPriority.specificMob = true
    end
    
    if Solar.Options["SelectWinterMobAutoFarm"] and Solar.Options["SelectWinterMobAutoFarm"].Value then
        winterMobFarmOptions.isAutoFarmEnabled = true
        farmPriority.winter = true
    end
    
    if isAnyFarmActive() then
        startGlobalFarmThread()
    end
end)

task.spawn(initAutoExecute)
